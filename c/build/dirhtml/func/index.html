

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-17487464-6']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>7. Functions &mdash; C Programming  documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="C Programming  documentation" href="../"/>
        <link rel="next" title="8. Structures and Unions" href="../su/"/>
        <link rel="prev" title="6. Arrays and Pointers" href="../ap/"/>
<link rel="stylesheet" href="../../css/math.css" type="text/css" />


  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../" class="icon icon-home"> C Programming
          

          
          </a>

          
            
            
              <div class="version">
                0.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search/" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../introduction/">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../basics/">2. Basics of C</a></li>
<li class="toctree-l1"><a class="reference internal" href="../io/">3. Console I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../oae/">4. Operators and Expressions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cf/">5. Control Flow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ap/">6. Arrays and Pointers</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">7. Functions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#pass-by-value">7.1. Pass-by-value</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pass-by-address">7.2. Pass-by-address</a></li>
<li class="toctree-l2"><a class="reference internal" href="#recursion">7.3. Recursion</a></li>
<li class="toctree-l2"><a class="reference internal" href="#function-like-macros">7.4. Function Like Macros</a></li>
<li class="toctree-l2"><a class="reference internal" href="#inline-functions">7.5. inline Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#function-pointers">7.6. Function Pointers</a></li>
<li class="toctree-l2"><a class="reference internal" href="#passing-and-receiving-function-pointers">7.7. Passing and Receiving Function Pointers</a></li>
<li class="toctree-l2"><a class="reference internal" href="#type-generic-functions">7.8. Type Generic Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#another-example">7.8.1. Another Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#type-compatibilty-in-an-expression">7.8.2. Type Compatibilty in an Expression</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../su/">8. Structures and Unions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../strings/">9. Strings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fileio/">10. File Input/Output</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fs/">11. Following Specification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../env/">12. Environment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lang/">13. Language</a></li>
<li class="toctree-l1"><a class="reference internal" href="../macros/">14. Preprocessing Directives</a></li>
<li class="toctree-l1"><a class="reference internal" href="../std/">15. The C Standard Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../assert/">16. Diagnostics <code class="docutils literal"><span class="pre">&lt;assert.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../complex/">17. Complex arithmetic <code class="docutils literal"><span class="pre">&lt;complex.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../ctypes/">18. Character Handling <code class="docutils literal"><span class="pre">&lt;ctype.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../errno/">19. Errors <code class="docutils literal"><span class="pre">&lt;errno.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../fenv/">20. Floating-point environment <code class="docutils literal"><span class="pre">&lt;fenv.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../float/">21. Characteristics of floating types <code class="docutils literal"><span class="pre">&lt;float.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../inttypes/">22. Format conversion of integer types <code class="docutils literal"><span class="pre">&lt;inttypes.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../iso646/">23. Alternative spellings <code class="docutils literal"><span class="pre">&lt;iso646.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../limits/">24. Sizes of integer types <code class="docutils literal"><span class="pre">&lt;limits.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../locale/">25. Localization &lt;locale.h&gt;</a></li>
<li class="toctree-l1"><a class="reference internal" href="../math/">26. Mathematics <code class="docutils literal"><span class="pre">&lt;math.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../setjmp/">27. Nonlocal jumps <code class="docutils literal"><span class="pre">&lt;setjmp.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../signal/">28. Signal handling <code class="docutils literal"><span class="pre">&lt;signal.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../stdarg/">29. Variable arguments <code class="docutils literal"><span class="pre">&lt;stdarg.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../stdbool/">30. Boolean type and values <code class="docutils literal"><span class="pre">&lt;stdbool.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../stddef/">31. Common definitions <code class="docutils literal"><span class="pre">&lt;stddef.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../stdint/">32. Integer types <code class="docutils literal"><span class="pre">&lt;stdint.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../stdio/">33. Input/output <code class="docutils literal"><span class="pre">&lt;stdio.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../stdlib/">34. General utilities <code class="docutils literal"><span class="pre">&lt;stdlib.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../string/">35. String handling <code class="docutils literal"><span class="pre">&lt;string.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../tgmath/">36. Type-generic math <code class="docutils literal"><span class="pre">&lt;tgmath.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../time/">37. Date and time <code class="docutils literal"><span class="pre">&lt;time.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../wchar/">38. Extended multibyte and wide character utilities <code class="docutils literal"><span class="pre">&lt;wchar.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../wtype/">39. Wide character classification and mapping utilities <code class="docutils literal"><span class="pre">&lt;wctype.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../problems/">40. Problems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../license/">41. License</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../">C Programming</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../">Docs</a> &raquo;</li>
      
    <li>7. Functions</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/func.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="functions">
<h1>7. Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h1>
<p>I know that you will readily agree with me if I say that humans get bored if
they have to do same things again and again. I know you get bored too and I too
get bored. We all. We as humans have this built-in nature that repititive
things are just not fit for us. Also, as a human being our capacity to
understand large things at once is difficult. We understand small-small things
and build large chunk based on those small things. Dennis Ritchie had known
this. I am saying because C has got something called functions. C functions
allow you to split a big logic into small ones and therefore facilitating
modular programming.
They also form the basis of strutctured programming the very base which made C
popular. There is also something called recursion which is a very poewrful tool.
In this chapter we will also see how to do multifile programming. I cannot
emphasize much that how important it is that you master the technique of
functions well and not to mention function pointers which can do the magic. I
will show you the very glimpse only. I can show you the way but walking on that
is your job. It is upto you to do the actual work. I have kept things simple and
minimal with a pupose. I do not want you to get bogged down with a thick and
heavy book. All my examples are toy examples but you have seen things can get
somehwat complex.</p>
<p>We have already seen the special <code class="docutils literal"><span class="pre">main()</span></code> function.</p>
<div class="section" id="pass-by-value">
<span id="index-0"></span><h2>7.1. Pass-by-value<a class="headerlink" href="#pass-by-value" title="Permalink to this headline">¶</a></h2>
<p>Here I am going to present skeleton of a function prototype and body.
Consider:</p>
<div class="highlight-python"><div class="highlight"><pre>//function prototype
return-type function-name(argument list); //here varible names may be ommitted

//function body
return-type function-name(argument list) //variable names cannot be ommitted``
{
  //your code here

  //call some other function
  function-name(arugment-list-without-type);

  return value-of-return-type;
}
</pre></div>
</div>
<p>This might be a bit abstract but please bear it a bit. In due course of time it
will become clear. You will be able to see in its concrete forms soon. Consider
a program which adds two numbers and let us say that you may need to add lots of
them.</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">//Author: Shiv S. Dayal</span>
<span class="c1">//Description: Demo of function</span>

<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">firstInt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">secondInt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d+%d=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">firstInt</span><span class="p">,</span> <span class="n">secondInt</span><span class="p">,</span> <span class="n">firstInt</span><span class="o">+</span><span class="n">secondInt</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">7</span><span class="p">;</span>

  <span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>output:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="mi">5</span><span class="o">+</span><span class="mi">7</span><span class="o">=</span><span class="mi">12</span>
</pre></div>
</div>
<p>Note that you need function body before its use else you need at least a function
prototype before use. If you do not do so you will get a compiler warnign. An
example is given below:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">//Author: Shiv S. Dayal</span>
<span class="c1">//Description: Demo of function</span>

<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="c1">//not how argument names are not required</span>
<span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">7</span><span class="p">;</span>

  <span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">firstInt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">secondInt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d+%d=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">firstInt</span><span class="p">,</span> <span class="n">secondInt</span><span class="p">,</span> <span class="n">firstInt</span><span class="o">+</span><span class="n">secondInt</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>output is same as above.</p>
<p>What you have seen just above is known as pass-by-value. In this case a copy of
parameters is made and passed on to called function by caller function. So, if
called function makes a change to values then those are not reflected back in
the caller function. As an example I will use famous example of swapping values
of two variables. First, I will show how pass-by-value works. So here is the
code:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">//Author: Shiv S. Dayal</span>
<span class="c1">//Description: Demo of function</span>

<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">7</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Before swap a=%d and b=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
  <span class="n">swap</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;After swap a=%d and b=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kt">int</span> <span class="n">firstArg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">secondArg</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">temp</span><span class="o">=</span><span class="n">firstArg</span><span class="p">;</span>
  <span class="n">firstArg</span><span class="o">=</span><span class="n">secondArg</span><span class="p">;</span>
  <span class="n">secondArg</span><span class="o">=</span><span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>output:</p>
<div class="highlight-python"><div class="highlight"><pre>Before swap a=5 and b=7
After swap a=5 and b=7
</pre></div>
</div>
</div>
<div class="section" id="pass-by-address">
<span id="index-1"></span><h2>7.2. Pass-by-address<a class="headerlink" href="#pass-by-address" title="Permalink to this headline">¶</a></h2>
<p>Not exactly what we wanted. The solution is to pass-by-address. When you the
address to a called function, it receives address in a pointer variable. Then if
it modifies the value stored at that address then it is reflected back in the
caller. Let us see an example to understand:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">//Author: Shiv S. Dayal</span>
<span class="c1">//Description: Demo of function</span>

<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">7</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Before swap a=%d and b=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
  <span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;After swap a=%d and b=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">firstArg</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">secondArg</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">temp</span><span class="o">=*</span><span class="n">firstArg</span><span class="p">;</span>
  <span class="o">*</span><span class="n">firstArg</span><span class="o">=*</span><span class="n">secondArg</span><span class="p">;</span>
  <span class="o">*</span><span class="n">secondArg</span><span class="o">=</span><span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>output:</p>
<div class="highlight-python"><div class="highlight"><pre>Before swap a=5 and b=7
After swap a=7 and b=5
</pre></div>
</div>
</div>
<div class="section" id="recursion">
<span id="index-2"></span><h2>7.3. Recursion<a class="headerlink" href="#recursion" title="Permalink to this headline">¶</a></h2>
<p>In C recusion is the concept of a function calling itself. When a repeated
operation has to be preformed over a variable, recursion can be used. Recursion
simplifies the code a lot. Typically there is always a more effective iterative
solutions are available but there are certain cases where recursion is always
better than iteration. For example, traversal of trees where iteration is not so
effective as compared to recursion. The first example I am going to give is that
of factorials. The formula for factorial is given by <span class="math">\(n!=\prod_{k=1}^n k\)</span>
and recursive definition of factorial is given by:</p>
<div class="math" id="index-3">
\[\begin{split}n!=\left\{\begin{array}{ll}
1 &amp; \quad\text{if n=0}\\
(n-1)!*n  &amp; \quad\text{if n&gt;0}
\end{array}\right.\end{split}\]</div>
<p>Note that every recursion has to be written carefully in thse sense that it must
have a termination condition and that in all the cases the termination condition
must be reached. If a recursion is too deep or infinite there will be a stack
overlow and the program will terminate. First, I will show you an iterative
version with a function.</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">//Author: Shiv S. Dayal</span>
<span class="c1">//Description: Iterative factorial.</span>

<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">long</span> <span class="kt">long</span> <span class="nf">fact</span><span class="p">(</span><span class="kt">int</span> <span class="n">input</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">input</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Enter a number whose input has to be computed:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">input</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Factorial of %d is %lld.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">input</span><span class="p">,</span> <span class="n">fact</span><span class="p">(</span><span class="n">input</span><span class="p">));</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">long</span> <span class="kt">long</span> <span class="nf">fact</span><span class="p">(</span><span class="kt">int</span> <span class="n">input</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">long</span> <span class="kt">long</span> <span class="n">output</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="n">input</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">output</span><span class="o">*=</span><span class="n">input</span><span class="p">;</span>
    <span class="n">input</span><span class="o">--</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">output</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>output:</p>
<div class="highlight-python"><div class="highlight"><pre>Enter a number whose factorial has to be computed:
17
Factorial of 17 is 355687428096000.
</pre></div>
</div>
<p>Now we will see recursive version:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">//Author: Shiv S. Dayal</span>
<span class="c1">//Description: Recursive factorial.</span>

<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">long</span> <span class="kt">long</span> <span class="nf">fact</span><span class="p">(</span><span class="kt">int</span> <span class="n">input</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">input</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Enter a number whose factorial has to be computed:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">input</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Factorial of %d is %lld.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">input</span><span class="p">,</span> <span class="n">fact</span><span class="p">(</span><span class="n">input</span><span class="p">));</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">long</span> <span class="kt">long</span> <span class="nf">fact</span><span class="p">(</span><span class="kt">int</span> <span class="n">input</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="n">input</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="n">fact</span><span class="p">(</span><span class="n">input</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">input</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>output:</p>
<div class="highlight-python"><div class="highlight"><pre>Enter a number whose factorial has to be computed:
16
Factorial of 16 is 20922789888000.
</pre></div>
</div>
<p>Recursion is very simple yet may be very deceptive to understand for beginners.
Let us dissect the code. Our input was 16 so if will not match and <code class="docutils literal"><span class="pre">return</span>
<span class="pre">fact(15)*16;</span></code> will be executed. Here, before <code class="docutils literal"><span class="pre">fact(16)</span></code> can return
<code class="docutils literal"><span class="pre">fact(15)</span></code> has to return. And, similarly before <code class="docutils literal"><span class="pre">fact(15)</span></code> can return
<code class="docutils literal"><span class="pre">fact(14)</span></code> has to return. Now, note that for <code class="docutils literal"><span class="pre">fact(0)</span></code> there is no such
condition and it can return 1 making it possible for <code class="docutils literal"><span class="pre">fact(1)</span></code> to return,
which, in turn will make it posiible for <code class="docutils literal"><span class="pre">fact(2)</span></code> to return and so on. So,
what is happening is function is calling itself by creating more and more
function frames and when the termination condition reaches the stack unwinds.</p>
<p id="index-4">Let us consider one more famous example for recursive function, that is of
computing Fibonacci numbers. The Fibonacci series is given by:</p>
<div class="math">
\[F_n = F_{n-1} + F_{n-2}\]</div>
<p>where first two numebrs are given by:</p>
<div class="math">
\[F_0 = 0  \text{ and }  F_1 = 1\]</div>
<p>First consider the iterative version:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">//Author: Shiv S. Dayal</span>
<span class="c1">//Description: Iterative Fibonacci series.</span>

<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">void</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="kt">int</span> <span class="n">input</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">input</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;How many Fibonacci numbers you want?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">input</span><span class="p">);</span>

  <span class="n">fibonacci</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="n">input</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">fib0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">fib1</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>

  <span class="k">if</span><span class="p">(</span><span class="n">input</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
  <span class="k">return</span><span class="p">;</span>
  <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">input</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fib0</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">input</span><span class="o">==</span><span class="mi">2</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fib0</span><span class="p">,</span> <span class="n">fib1</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">input</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d %d&quot;</span><span class="p">,</span> <span class="n">fib0</span><span class="p">,</span> <span class="n">fib1</span><span class="p">);</span>
    <span class="k">while</span><span class="p">(</span><span class="n">input</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">fib1</span><span class="o">=</span><span class="n">fib1</span><span class="o">+</span><span class="n">fib0</span><span class="p">;</span>
      <span class="n">fib0</span><span class="o">=</span><span class="n">fib1</span><span class="o">-</span><span class="n">fib0</span><span class="p">;</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&quot; %d&quot;</span><span class="p">,</span> <span class="n">fib1</span><span class="p">);</span>
      <span class="n">input</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>output:</p>
<div class="highlight-python"><div class="highlight"><pre>How many Fibonacci numbers you want?
16
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
</pre></div>
</div>
<p>Now we will see recursive version:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">//Author: Shiv S. Dayal</span>
<span class="c1">//Description: iRecursive Fibonacci series.</span>

<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">long</span> <span class="kt">long</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="kt">int</span> <span class="n">input</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">input</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Which Fibonacci number you want?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">input</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%lld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">input</span><span class="p">));</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">long</span> <span class="kt">long</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="kt">int</span> <span class="n">input</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">long</span> <span class="kt">long</span> <span class="n">fib0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">fib1</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>

  <span class="k">if</span><span class="p">(</span><span class="n">input</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">fib0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">input</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">fib1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">fib</span> <span class="o">=</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">input</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">fibonacci</span><span class="p">(</span><span class="n">input</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">fib</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>output:</p>
<div class="highlight-python"><div class="highlight"><pre>Which Fibonacci number you want?
32
2178309
</pre></div>
</div>
</div>
<div class="section" id="function-like-macros">
<span id="index-5"></span><h2>7.4. Function Like Macros<a class="headerlink" href="#function-like-macros" title="Permalink to this headline">¶</a></h2>
<p>Functions are costly if they are very small. For example, let us say we want to
add two integers only then it does not make sense to write a function. When you
call a function a new function frame has to be created, new variables are
created, when function returns things are cleaned and return value is returned.
All this consume memory and CPU cycles so old C style was to use macros. For
example, consider following program:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">//Author: Shiv S. Dayal</span>
<span class="c1">//Description: Demo of macros.</span>

<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="cp">#define SUM(a, b) a+b</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">SUM</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="n">SUM</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">));</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>output:</p>
<div class="highlight-python"><div class="highlight"><pre>12 17
</pre></div>
</div>
<p>However, such usage of macros are inappropriate, dangerous and higly advised
against. First you have to take care that you parenthesize all parameters
carefully. Even then consider following:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#define MIN(a,b)  ((a)&lt;(b))?(a):(b);</span>
</pre></div>
</div>
<p>If it get a call like:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">3</span><span class="p">;</span>
<span class="n">MIN</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="o">++</span><span class="n">b</span><span class="p">)</span><span class="c1">//then macro will expand to</span>
<span class="p">((</span><span class="n">a</span><span class="p">)</span><span class="o">&lt;</span><span class="p">(</span><span class="o">++</span><span class="n">b</span><span class="p">))</span><span class="o">?</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">:</span><span class="p">(</span><span class="o">++</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
<p>Now since <code class="docutils literal"><span class="pre">b</span></code> is less than <code class="docutils literal"><span class="pre">a</span></code> it will be incremented twice otherwise it
will be incremented once. Such behavior is confusing at best. Older C
programmers had no choice but only macros. But with new C99 standard we have
something called inline functions. New C99 programmers have no excuse for
writing macros like shown above.</p>
</div>
<div class="section" id="inline-functions">
<span id="index-6"></span><h2>7.5. inline Functions<a class="headerlink" href="#inline-functions" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal"><span class="pre">inline</span></code> functions are somewhat a mix of macros and functions. It is a request
to compiler to expand the code inline like macros while maintaining the
type-safety of functions. Note that it is a request not a command. Compilers may
choose to ignore the request of inline expansion of code if the inline function
is too complicated. Also, recursive functions are not inlined. You should use
inline functions to replace small functions only. The reasons are being that you
may get problems mentioned in Item 33 of &#8220;Effective C++&#8221; by Scott Meyers. For
smaller functions you have a much higher chance of getting your functions
inlined. To use the inline function you just need to prefix the function
signature and prototype declaration with keyword inline. For smaller functions
code generated for inline functions will outweigh the overhead which is there
for function calls. However, if you inline too much the size of your binary will
become bigger and bigger and it may be a problem on systems; straved for memory;
in systems like embedded systems. Typically inline functoins are declared in
headers so that all source files can benefit from it. However, this may cause
problems if functions are not inlined by compiler.</p>
<p>For example, the above <cite>MAX</cite> function can be rewritten as following:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">MAX</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">?</span><span class="nl">a</span><span class="p">:</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>One of the advantages of inline functions is type safety. Macros do not care
about type safety which can cause run-time surprizes.</p>
</div>
<div class="section" id="function-pointers">
<span id="index-7"></span><h2>7.6. Function Pointers<a class="headerlink" href="#function-pointers" title="Permalink to this headline">¶</a></h2>
<p>These are very powerful but have got somewhat complex syntax. Due to their
complex syntax programmers typically shun them. However, they are must if you
want to do certain stuff which C typically does not allow, like, object oriented
programming, generic programming, switch/if statement replacement etc. to name a
few. New programmers may wonder how can we have pointers to functions as they
are not variables. Well they are not varibles that I agree but still their
addresses can be taken. However, their addresses lie in code segment or text
segment which happens to be read-only area, hence, that address cannot be
modified. Let us consider a program of a desk calculator with four
operations. Addition, subtraction, multiplication and division. As a typical
desk calculator I will take double as data type as it has sufficient range and
precision. How would you write such a program? Well with our current knowledge
we can write four functions for four operations. Then we can use a switch for
choosing the function. Let us see it in action:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">//Author: Shiv S. Dayal</span>
<span class="c1">//Description: Demo of function pointers.</span>

<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">op</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">op1</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span><span class="n">op2</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span><span class="n">result</span><span class="o">=</span><span class="mf">0.0</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Enter operation (should be one of + - * /):&quot;</span><span class="p">);</span>
  <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%c&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Enter two operands separated by a space:&quot;</span><span class="p">);</span>
  <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%lf %lf&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op2</span><span class="p">);</span>

  <span class="k">switch</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">case</span> <span class="sc">&#39;+&#39;</span><span class="o">:</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">op1</span> <span class="o">+</span> <span class="n">op2</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="sc">&#39;-&#39;</span><span class="o">:</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">op1</span> <span class="o">-</span> <span class="n">op2</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="sc">&#39;*&#39;</span><span class="o">:</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">op1</span> <span class="o">*</span> <span class="n">op2</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="sc">&#39;/&#39;</span><span class="o">:</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">op1</span> <span class="o">/</span> <span class="n">op2</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">default</span><span class="o">:</span>
      <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%lf%c%lf=%lf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">op1</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">op2</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>and the output is:</p>
<div class="highlight-python"><div class="highlight"><pre>Enter operation (should be one of + - * /):+
Enter two operands separated by a space: 2.4 1.2
2.400000+1.200000=3.600000
</pre></div>
</div>
<p>As you can see depending on the operation the switch statement performs the
operation on two operands. We can use function pointers to replace this swiccth
statement:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">//Author: Shiv S. Dayal</span>
<span class="c1">//Description: Demo of function pointers.</span>

<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cm">/* Since there are four arithmetic operations we need four function pointers.*/</span>

<span class="kt">float</span> <span class="nf">plus</span><span class="p">(</span><span class="kt">double</span> <span class="n">op1</span><span class="p">,</span> <span class="kt">double</span> <span class="n">op2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">result</span><span class="o">=</span><span class="mf">0.0</span><span class="p">;</span>

  <span class="n">result</span><span class="o">=</span><span class="n">op1</span><span class="o">+</span><span class="n">op2</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%lf+%lf=%lf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">float</span> <span class="nf">minus</span><span class="p">(</span><span class="kt">double</span> <span class="n">op1</span><span class="p">,</span> <span class="kt">double</span> <span class="n">op2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">result</span><span class="o">=</span><span class="mf">0.0</span><span class="p">;</span>

  <span class="n">result</span><span class="o">=</span><span class="n">op1</span><span class="o">-</span><span class="n">op2</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%lf-%lf=%lf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">float</span> <span class="nf">multiply</span><span class="p">(</span><span class="kt">double</span> <span class="n">op1</span><span class="p">,</span> <span class="kt">double</span> <span class="n">op2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">result</span><span class="o">=</span><span class="mf">0.0</span><span class="p">;</span>

  <span class="n">result</span><span class="o">=</span><span class="n">op1</span><span class="o">*</span><span class="n">op2</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%lf*%lf=%lf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">float</span> <span class="nf">divide</span><span class="p">(</span><span class="kt">double</span> <span class="n">op1</span><span class="p">,</span> <span class="kt">double</span> <span class="n">op2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">result</span><span class="o">=</span><span class="mf">0.0</span><span class="p">;</span>

  <span class="n">result</span><span class="o">=</span><span class="n">op1</span><span class="o">/</span><span class="n">op2</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%lf/%lf=%lf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">call_fp</span><span class="p">(</span><span class="kt">double</span> <span class="n">op1</span><span class="p">,</span> <span class="kt">double</span> <span class="n">op2</span><span class="p">,</span> <span class="kt">float</span> <span class="p">(</span><span class="o">*</span><span class="n">pt2Func</span><span class="p">)(</span><span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="p">))</span>
<span class="p">{</span>
  <span class="n">pt2Func</span><span class="p">(</span><span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Execute example code</span>
<span class="kt">void</span> <span class="nf">Switch</span><span class="p">(</span><span class="kt">double</span> <span class="n">op1</span><span class="p">,</span> <span class="kt">double</span> <span class="n">op2</span><span class="p">,</span> <span class="kt">char</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">switch</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">case</span> <span class="sc">&#39;+&#39;</span><span class="o">:</span>
      <span class="n">call_fp</span><span class="p">(</span><span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">plus</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="sc">&#39;-&#39;</span><span class="o">:</span>
      <span class="n">call_fp</span><span class="p">(</span><span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">minus</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="sc">&#39;*&#39;</span><span class="o">:</span>
      <span class="n">call_fp</span><span class="p">(</span><span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">multiply</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="sc">&#39;/&#39;</span><span class="o">:</span>
      <span class="n">call_fp</span><span class="p">(</span><span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">divide</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">default</span><span class="o">:</span>
      <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">op</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">op1</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">op2</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">result</span><span class="o">=</span><span class="mf">0.0</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Enter operation (should be one of + - * /):&quot;</span><span class="p">);</span>
  <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%c&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Enter two operands separated by a space:&quot;</span><span class="p">);</span>
  <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%lf %lf&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op2</span><span class="p">);</span>

  <span class="n">Switch</span><span class="p">(</span><span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">,</span> <span class="n">op</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>output:</p>
<div class="highlight-python"><div class="highlight"><pre>Enter operation (should be one of + - * /):+
Enter two operands separated by a space:2.4
1.2
2.400000+1.200000=3.600000
</pre></div>
</div>
<p>So you see how a <code class="docutils literal"><span class="pre">switch</span></code> statement can be replaced with function pointers. The
abstract declaration of a function pointer is given below:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">return_type</span> <span class="p">(</span><span class="o">*</span><span class="n">function_name</span><span class="p">)(</span><span class="n">arguments</span><span class="p">);</span>
</pre></div>
</div>
<p>You can call these functions in two ways:</p>
<div class="highlight-python"><div class="highlight"><pre>function_name(arguments); //shortcut call
(*function_name)(arguments); //long and correct call
</pre></div>
</div>
<p>You should always prefer the second version as it is more portable across
different compilers and environments.</p>
</div>
<div class="section" id="passing-and-receiving-function-pointers">
<span id="index-8"></span><h2>7.7. Passing and Receiving Function Pointers<a class="headerlink" href="#passing-and-receiving-function-pointers" title="Permalink to this headline">¶</a></h2>
<p>You have already seen how to pass a function pointer as an argument to a second
function in the above exercise. <code class="docutils literal"><span class="pre">call_fp(op1,op2,</span> <span class="pre">&amp;plus);</span></code> is where you pass
a function pointer and <code class="docutils literal"><span class="pre">void</span> <span class="pre">call_fp(doubleop1,</span> <span class="pre">double</span> <span class="pre">op2,</span> <span class="pre">float</span>
<span class="pre">(*pt2Func)(double,</span> <span class="pre">double))</span></code> is where you receive it as an argument.</p>
<p>You can also return a function pointer from some function. Consider the
following:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">return_type</span> <span class="p">(</span><span class="o">*</span><span class="n">func1</span><span class="p">(</span><span class="n">arguments1</span><span class="p">))(</span><span class="n">arguments2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="n">func2</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This piece of code is a function whose name is <code class="docutils literal"><span class="pre">func1</span></code>, it takes <code class="docutils literal"><span class="pre">arguments1</span></code>
as its arguments and returns <code class="docutils literal"><span class="pre">float</span></code>. The return value is a function pointer
<code class="docutils literal"><span class="pre">func2</span></code> whose arguments are <code class="docutils literal"><span class="pre">arguments2</span></code>. However, this kind of declaration
is messy and hard to read so we have a solution which makes things easier on us.
Consider a following <code class="docutils literal"><span class="pre">typedef</span></code> and function signature:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">typedef</span> <span class="nf">return_type</span> <span class="p">(</span><span class="o">*</span><span class="n">function1</span><span class="p">)(</span><span class="n">arguments</span><span class="p">);</span>
<span class="n">function1</span> <span class="nf">function2</span><span class="p">(</span><span class="n">arguments</span><span class="p">);</span>
</pre></div>
</div>
<p>This is much simpler and cleaner. It is also easier to understand than above.</p>
<p>Similarly you can declare an array of function pointers. This offers the feature
of selection of a function using an index. For example, the menu bar of most of
the GUI programns can be accessed using this. Similarly, there are two ways again
to declare the array of function pointers. The first one is without using typedef
and second one is using <code class="docutils literal"><span class="pre">typedef</span></code>. The choice is yours that which one you want
to use. I prefer the <code class="docutils literal"><span class="pre">typedef</span></code> version. The syntax is given below:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">typedef</span> <span class="nf">return_type</span> <span class="p">(</span><span class="o">*</span><span class="n">function1</span><span class="p">)(</span><span class="n">arguments</span><span class="p">);</span>
<span class="n">function1</span> <span class="n">array_of_fp</span><span class="p">[</span><span class="n">MAX</span><span class="p">];</span>

<span class="n">return_type</span> <span class="p">(</span><span class="o">*</span><span class="n">function2</span><span class="p">[</span><span class="n">MAX</span><span class="p">])(</span><span class="n">arguments</span><span class="p">);</span>
</pre></div>
</div>
<p>One of the more clever usage of function pointers can be found in the library
function <code class="docutils literal"><span class="pre">qsort</span></code> where you have to write the comparison function which is a
callback function. Given below os the signature of qsort function.</p>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">qsort</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">comp</span><span class="p">)</span> <span class="p">(</span>
            <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span> <span class="p">)</span> <span class="p">);</span>
</pre></div>
</div>
<p>The brief description is given here. Sorts the count elements of the array
pointed by <code class="docutils literal"><span class="pre">a</span></code>, each element <code class="docutils literal"><span class="pre">size</span></code> bytes long, using the compa function to
determine the order.</p>
<p>The sorting algorithm used by this function compares pairs of values by calling
the specified comparator function with two pointers to elements of the array.</p>
<p>The function does not return any value, but modifies the content of the array
pointed by base reordering its elements to the newly sorted order.
Let us see an example:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">//Author: Shiv S. Dayal</span>
<span class="c1">//Description: Demo of qsort.</span>

<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>

<span class="kt">int</span> <span class="n">values</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">25</span> <span class="p">};</span>

<span class="kt">int</span> <span class="nf">compare</span> <span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">a</span> <span class="o">-</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">b</span> <span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

  <span class="n">qsort</span> <span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="n">compare</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">n</span><span class="o">&lt;</span><span class="mi">9</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span>
    <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span><span class="n">values</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>and the output is:</p>
<div class="highlight-python"><div class="highlight"><pre>1 3 4 4 7 10 9 20 25
</pre></div>
</div>
</div>
<div class="section" id="type-generic-functions">
<h2>7.8. Type Generic Functions<a class="headerlink" href="#type-generic-functions" title="Permalink to this headline">¶</a></h2>
<p>C11 has introduced a new type of functions called type generic functions. If
you read clause 2 of <code class="docutils literal"><span class="pre">tgmath.</span></code> then you will find following.</p>
<p>Of the <code class="docutils literal"><span class="pre">&lt;math.h&gt;</span></code> and <code class="docutils literal"><span class="pre">&lt;complex.h&gt;</span></code> functions without an <code class="docutils literal"><span class="pre">f</span></code> (<code class="docutils literal"><span class="pre">float</span></code>)
or <code class="docutils literal"><span class="pre">l</span></code> (<code class="docutils literal"><span class="pre">long</span> <span class="pre">double</span></code>) suffix, several have one or more parameters whose
corresponding real type is <code class="docutils literal"><span class="pre">double</span></code>. For each such function, except <code class="docutils literal"><span class="pre">modf</span></code>,
there is a corresponding type-generic macro. <a class="footnote-reference" href="#id3" id="id1">[1]</a> The parameters whose
corresponding real type is <code class="docutils literal"><span class="pre">double</span></code> in the function synopsis are generic
parameters. Use of the macro invokes a function whose corresponding real type
and type domain are determined by the arguments for the generic
parameters. <a class="footnote-reference" href="#id4" id="id2">[2]</a></p>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Like other function-like macros in Standard libraries, each type-generic
macro can be suppressed to make available the corresponding ordinary
function.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>If the type of the argument is not compatible with the type of the
parameter for the selected function, the behavior is undefined.</td></tr>
</tbody>
</table>
<p>Since we have three different floating-point types and three different versions
of complex numbers (<code class="docutils literal"><span class="pre">float,</span> <span class="pre">double</span></code> and <code class="docutils literal"><span class="pre">long</span> <span class="pre">double</span></code>) therefore we have
six versions of each function which will be called based on argument type.</p>
<p>This is achieved through keyword <code class="docutils literal"><span class="pre">_Generic</span></code> which is used to create a generic
selection expression. For example, consider the following code:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">_Generic</span><span class="p">((</span><span class="mi">6</span><span class="p">),</span> <span class="kt">char</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="kt">int</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span> <span class="kt">long</span><span class="o">:</span> <span class="mi">3</span><span class="p">,</span> <span class="k">default</span><span class="o">:</span> <span class="mi">0</span><span class="p">));</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that you need version 4.9 of <code class="docutils literal"><span class="pre">gcc</span></code> or <code class="docutils literal"><span class="pre">clang</span></code> to compile this. I am
using <code class="docutils literal"><span class="pre">clang</span></code> version 3.4 to compile this program. The output is:</p>
<div class="highlight-text"><div class="highlight"><pre>2
</pre></div>
</div>
<p>as you can see we are passing 6 which is an integer and value 2 is associated
with the <code class="docutils literal"><span class="pre">int</span></code> therefore the output is 2.</p>
<p>We can make a macro which will allow us to reuse the functionality. For
example:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="cp">#define type(T) _Generic( (T), char: 1, int: 2, long: 3, default: 0)</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">type</span><span class="p">(</span><span class="mi">87364563853</span><span class="p">));</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>which will output 3 because value passed is <code class="docutils literal"><span class="pre">long</span></code>.</p>
<p>The grammar is given below:</p>
<dl class="docutils">
<dt><em>generic-selection:</em></dt>
<dd><em>_Generic ( assignment-expression , generic-assoc-list )</em></dd>
<dt><em>generic-assoc-list:</em></dt>
<dd><p class="first"><em>generic-association</em></p>
<p class="last"><em>generic-assoc-list , generic-association</em></p>
</dd>
<dt><em>generic-association:</em></dt>
<dd><p class="first"><em>type-name : assignment-expression</em></p>
<p class="last"><em>default : assignment-expression</em></p>
</dd>
</dl>
<p>Section 6.5.1.1 of n1570.pdf describes generic selection in great detail. To
summarize following points can be noted:</p>
<ul class="simple">
<li>A generic selection consists of a controlling expression (which is not
evaluated) and one or more, comma-separated, generic associations.</li>
<li>Each generic association consists of a type-name (or default) and a result
expression separated by a colon.</li>
<li>The result of the generic selection expression is the result expression of
the corresponding compatible type provided in the matching generic
association.</li>
<li>If none of the provided types are compatible with the type of the controlling
expression, a default selection is used if provided, otherwise the construct
is erroneous.</li>
<li>The order of the generic associations in the list is inconsequential; no more
than one compatible type may be provided in a generic selection so there is
never more than one case that could match.</li>
<li>The type and value of a generic selection are identical to those of its
result expression. It is an lvalue, a function designator, or a void
expression if its result expression is, respectively, an lvalue, a function
designator, or a void expression.</li>
</ul>
<p>A pseudo type-polymorphism is used to provide <code class="docutils literal"><span class="pre">_Generic</span></code> facility. For
example, the <code class="docutils literal"><span class="pre">acos</span></code> macro defined in <code class="docutils literal"><span class="pre">tgmath.h</span></code> could be implemented as:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#define acos(X) _Generic((X), \</span>
<span class="cp">  long double complex: cacosl, \</span>
<span class="cp">  double complex: cacos, \</span>
<span class="cp">  float complex: cacosf, \</span>
<span class="cp">  long double: acosl, \</span>
<span class="cp">  float: acosf, \</span>
<span class="cp">  default: acos \</span>
<span class="cp">)(X)</span>
</pre></div>
</div>
<p>Multiple arguments are far more complex. For example,</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#define pow(x, y) _Generic((x), \</span>
<span class="cp">  long double complex: cpowl, \</span>

  <span class="kt">double</span> <span class="nl">complex</span><span class="p">:</span> <span class="n">_Generic</span><span class="p">((</span><span class="n">y</span><span class="p">),</span> \
  <span class="kt">long</span> <span class="kt">double</span> <span class="nl">complex</span><span class="p">:</span> <span class="n">cpowl</span><span class="p">,</span> \
  <span class="k">default</span><span class="o">:</span> <span class="n">cpow</span><span class="p">),</span> \

  <span class="kt">float</span> <span class="nl">complex</span><span class="p">:</span> <span class="n">_Generic</span><span class="p">((</span><span class="n">y</span><span class="p">),</span> \
  <span class="kt">long</span> <span class="kt">double</span> <span class="nl">complex</span><span class="p">:</span> <span class="n">cpowl</span><span class="p">,</span> \
  <span class="kt">double</span> <span class="nl">complex</span><span class="p">:</span> <span class="n">cpow</span><span class="p">,</span> \
  <span class="k">default</span><span class="o">:</span> <span class="n">cpowf</span><span class="p">),</span> \

  <span class="kt">long</span> <span class="kt">double</span><span class="o">:</span> <span class="n">_Generic</span><span class="p">((</span><span class="n">y</span><span class="p">),</span> \
  <span class="kt">long</span> <span class="kt">double</span> <span class="nl">complex</span><span class="p">:</span> <span class="n">cpowl</span><span class="p">,</span> \
  <span class="kt">double</span> <span class="nl">complex</span><span class="p">:</span> <span class="n">cpow</span><span class="p">,</span> \
  <span class="kt">float</span> <span class="nl">complex</span><span class="p">:</span> <span class="n">cpowf</span><span class="p">,</span> \
  <span class="k">default</span><span class="o">:</span> <span class="n">powl</span><span class="p">),</span> \

  <span class="k">default</span><span class="o">:</span> <span class="n">_Generic</span><span class="p">((</span><span class="n">y</span><span class="p">),</span> \
  <span class="kt">long</span> <span class="kt">double</span> <span class="nl">complex</span><span class="p">:</span> <span class="n">cpowl</span><span class="p">,</span> \
  <span class="kt">double</span> <span class="nl">complex</span><span class="p">:</span> <span class="n">cpow</span><span class="p">,</span> \
  <span class="kt">float</span> <span class="nl">complex</span><span class="p">:</span> <span class="n">cpowf</span><span class="p">,</span> \
  <span class="kt">long</span> <span class="kt">double</span><span class="o">:</span> <span class="n">powl</span><span class="p">,</span> \
  <span class="k">default</span><span class="o">:</span> <span class="n">pow</span><span class="p">),</span> \

  <span class="kt">float</span><span class="o">:</span> <span class="n">_Generic</span><span class="p">((</span><span class="n">y</span><span class="p">),</span> \
  <span class="kt">long</span> <span class="kt">double</span> <span class="nl">complex</span><span class="p">:</span> <span class="n">cpowl</span><span class="p">,</span> \
  <span class="kt">double</span> <span class="nl">complex</span><span class="p">:</span> <span class="n">cpow</span><span class="p">,</span> \
  <span class="kt">float</span> <span class="nl">complex</span><span class="p">:</span> <span class="n">cpowf</span><span class="p">,</span> \
  <span class="kt">long</span> <span class="kt">double</span><span class="o">:</span> <span class="n">powl</span><span class="p">,</span> \
  <span class="kt">float</span><span class="o">:</span> <span class="n">powf</span><span class="p">,</span> \
  <span class="k">default</span><span class="o">:</span> <span class="n">pow</span><span class="p">)</span> \
<span class="p">)(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="another-example">
<h3>7.8.1. Another Example<a class="headerlink" href="#another-example" title="Permalink to this headline">¶</a></h3>
<p>Similar to selecting the name of a function to call based on the argument type,
we can select, for example, a printf format specifier based on type. This
allows the creation of a macro that can print any type of value that printf
supports without having to specify the type explicitly in the call:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#define printf_dec_format(x) _Generic((x), \</span>
<span class="cp">    char: &quot;%c&quot;, \</span>
<span class="cp">    signed char: &quot;%hhd&quot;, \</span>
<span class="cp">    unsigned char: &quot;%hhu&quot;, \</span>
<span class="cp">    signed short: &quot;%hd&quot;, \</span>
<span class="cp">    unsigned short: &quot;%hu&quot;, \</span>
<span class="cp">    signed int: &quot;%d&quot;, \</span>
<span class="cp">    unsigned int: &quot;%u&quot;, \</span>
<span class="cp">    long int: &quot;%ld&quot;, \</span>
<span class="cp">    unsigned long int: &quot;%lu&quot;, \</span>
<span class="cp">    long long int: &quot;%lld&quot;, \</span>
<span class="cp">    unsigned long long int: &quot;%llu&quot;, \</span>
<span class="cp">    float: &quot;%f&quot;, \</span>
<span class="cp">    double: &quot;%f&quot;, \</span>
<span class="cp">    long double: &quot;%Lf&quot;, \</span>
<span class="cp">    char *: &quot;%s&quot;, \</span>
<span class="cp">    void *: &quot;%p&quot;)</span>

<span class="cp">#define print(x) printf(printf_dec_format(x), x)</span>
<span class="cp">#define printnl(x) printf(printf_dec_format(x), x), printf(&quot;\n&quot;);</span>

<span class="n">printnl</span><span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="p">);</span>    <span class="c1">// prints &quot;97&quot; (on an ASCII system)</span>
<span class="n">printnl</span><span class="p">((</span><span class="kt">char</span><span class="p">)</span><span class="sc">&#39;a&#39;</span><span class="p">);</span>  <span class="c1">// prints &quot;a&quot;</span>
<span class="n">printnl</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span>    <span class="c1">// prints &quot;123&quot;</span>
<span class="n">printnl</span><span class="p">(</span><span class="mf">1.234</span><span class="p">);</span>      <span class="c1">// prints &quot;1.234000&quot;</span>
</pre></div>
</div>
<p>Note that since &#8216;a&#8217; is an <code class="docutils literal"><span class="pre">int</span></code> because characters are fundamentally integers
we have to cast it to a <code class="docutils literal"><span class="pre">char</span></code> if we want to print out the letter.</p>
<p>A string literal like <code class="docutils literal"><span class="pre">printnl(&quot;abc&quot;)</span></code> will produce error. The reason is that
the type of this string is <code class="docutils literal"><span class="pre">char</span> <span class="pre">[4]</span></code> while we have type as <code class="docutils literal"><span class="pre">char*</span></code> so we
can cast to that. However, section 6.3.1.2 clause 3 states</p>
<blockquote>
<div>Except when it is the operand of the sizeof operator, the <code class="docutils literal"><span class="pre">_Alignof</span></code>
operator, or the unary <code class="docutils literal"><span class="pre">&amp;</span></code> operator, or is a string literal used to
initialize an array, an expression that has type &#8220;array of type&#8221; is
converted to an expression with type &#8220;pointer to type&#8221; that points to the
initial element of the array object and is not an lvalue. If the array object
has register storage class, the behavior is undefined.</div></blockquote>
<p>This clause makes no mention of <code class="docutils literal"><span class="pre">_Generic</span></code> so we can assume that the
conversion should occur in this case, this may be a defect in <code class="docutils literal"><span class="pre">clang</span></code>.</p>
</div>
<div class="section" id="type-compatibilty-in-an-expression">
<h3>7.8.2. Type Compatibilty in an Expression<a class="headerlink" href="#type-compatibilty-in-an-expression" title="Permalink to this headline">¶</a></h3>
<p>A macro can be created that evaluates to <code class="docutils literal"><span class="pre">true</span></code> if an expression is compatible
with the provided type: <code class="docutils literal"><span class="pre">#define</span> <span class="pre">is_compatible(x,</span> <span class="pre">T)</span> <span class="pre">_Generic((x),</span> <span class="pre">T:1,</span>
<span class="pre">default:</span> <span class="pre">0)</span></code></p>
<p>This can be useful for determining the underlying type of a <code class="docutils literal"><span class="pre">typedef</span></code> or
<code class="docutils literal"><span class="pre">enum</span></code>: <code class="docutils literal"><span class="pre">is_compatible((size_t){0},</span> <span class="pre">unsigned</span> <span class="pre">long);</span></code></p>
<p>will evaluate to <code class="docutils literal"><span class="pre">true</span></code> if <code class="docutils literal"><span class="pre">size_t</span></code> is a <code class="docutils literal"><span class="pre">typedef</span></code> for <code class="docutils literal"><span class="pre">unsigned</span>
<span class="pre">long</span></code>. Note that we can only compare an expression with a type, we cannot
directly compare two expressions or two type names. If we want to compare two
types, we can use the C99 compound literal to create a literal of a given type
as we did above. There is no standard-conforming way to test two variables for
type compatibility with this mechanism. On a compiler that supports the common
typeof extension, something like this may work: <code class="docutils literal"><span class="pre">is_compatible(x,</span>
<span class="pre">typeof(y));</span></code></p>
<p><code class="docutils literal"><span class="pre">_Generic</span></code> is evaluated at compile-time and can be used with _Static_assert
if the result is an integer constant expression:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">enum</span> <span class="n">e</span> <span class="p">{</span> <span class="n">E1</span><span class="p">;</span> <span class="p">};</span>
<span class="n">_Static_assert</span><span class="p">(</span><span class="n">is_compatible</span><span class="p">(</span><span class="n">E1</span><span class="p">),</span> <span class="kt">int</span><span class="p">);</span>  <span class="c1">// always true</span>
<span class="n">_Static_assert</span><span class="p">(</span><span class="n">is_compatible</span><span class="p">((</span><span class="k">enum</span> <span class="n">e</span><span class="p">){</span><span class="n">E1</span><span class="p">},</span> <span class="kt">int</span><span class="p">);</span>  <span class="c1">// not necessarily true</span>
</pre></div>
</div>
<p>It is possible to define a macro to ensure that an expression, perhaps a
function argument, is of a given type:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#define ensure_type(p, t) _Static_assert(is_compatible(p, t), \</span>
<span class="cp">&quot;incorrect type for parameter &#39;&quot; #p &quot;&#39;, expected &quot; #t)</span>
</pre></div>
</div>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../su/" class="btn btn-neutral float-right" title="8. Structures and Unions" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../ap/" class="btn btn-neutral" title="6. Arrays and Pointers" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2012-2015, Shiv S. Dayal.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>