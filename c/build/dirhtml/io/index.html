<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>3. Console I/O &mdash; C99  documentation</title>
    
    <link rel="stylesheet" href="../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-3.1.0/css/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-3.1.0/css/bootstrap-theme.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-3.1.0/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-sphinx.js"></script>
    <link rel="top" title="C99  documentation" href="../" />
    <link rel="next" title="4. Operators and Expressions" href="../oae/" />
    <link rel="prev" title="2. Basics of C" href="../basics/" />
<script src="../_static/analytics.js" type="text/javascript"></script>
<link rel="stylesheet" href="../../../css/math.css" type="text/css" />

  </head>
  <body>




  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="/">Home</a>
        <a class="navbar-brand" href="../">
          C99</a>
        <span class="navbar-text navbar-version pull-left"><b>0.2</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            <li class="divider-vertical"></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../introduction/">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../basics/">2. Basics of C</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">3. Console I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../oae/">4. Operators and Expressions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cf/">5. Control Flow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ap/">6. Arrays and Pointers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../func/">7. Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../su/">8. Structures and Unions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fs/">9. Following Specification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../env/">10. Environment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lang/">11. Language</a></li>
<li class="toctree-l1"><a class="reference internal" href="../macros/">12. Preprocessing Directives</a></li>
<li class="toctree-l1"><a class="reference internal" href="../std/">13. The C Standard Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../assert/">14. Diagnostics <tt class="docutils literal"><span class="pre">&lt;assert.h&gt;</span></tt></a></li>
<li class="toctree-l1"><a class="reference internal" href="../complex/">15. Complex arithmetic <tt class="docutils literal"><span class="pre">&lt;complex.h&gt;</span></tt></a></li>
<li class="toctree-l1"><a class="reference internal" href="../ctypes/">16. Character Handling <tt class="docutils literal"><span class="pre">&lt;ctype.h&gt;</span></tt></a></li>
<li class="toctree-l1"><a class="reference internal" href="../errno/">17. Errors <tt class="docutils literal"><span class="pre">&lt;errno.h&gt;</span></tt></a></li>
<li class="toctree-l1"><a class="reference internal" href="../fenv/">18. Floating-point environment <tt class="docutils literal"><span class="pre">&lt;fenv.h&gt;</span></tt></a></li>
<li class="toctree-l1"><a class="reference internal" href="../float/">19. Characteristics of floating types <tt class="docutils literal"><span class="pre">&lt;float.h&gt;</span></tt></a></li>
<li class="toctree-l1"><a class="reference internal" href="../inttypes/">20. Format conversion of integer types <tt class="docutils literal"><span class="pre">&lt;inttypes.h&gt;</span></tt></a></li>
<li class="toctree-l1"><a class="reference internal" href="../iso646/">21. Alternative spellings <tt class="docutils literal"><span class="pre">&lt;iso646.h&gt;</span></tt></a></li>
<li class="toctree-l1"><a class="reference internal" href="../limits/">22. Sizes of integer types <tt class="docutils literal"><span class="pre">&lt;limits.h&gt;</span></tt></a></li>
<li class="toctree-l1"><a class="reference internal" href="../locale/">23. Localization &lt;locale.h&gt;</a></li>
<li class="toctree-l1"><a class="reference internal" href="../math/">24. Mathematics <tt class="docutils literal"><span class="pre">&lt;math.h&gt;</span></tt></a></li>
<li class="toctree-l1"><a class="reference internal" href="../setjmp/">25. Nonlocal jumps <tt class="docutils literal"><span class="pre">&lt;setjmp.h&gt;</span></tt></a></li>
<li class="toctree-l1"><a class="reference internal" href="../signal/">26. Signal handling <tt class="docutils literal"><span class="pre">&lt;signal.h&gt;</span></tt></a></li>
<li class="toctree-l1"><a class="reference internal" href="../stdarg/">27. Variable arguments <tt class="docutils literal"><span class="pre">&lt;stdarg.h&gt;</span></tt></a></li>
<li class="toctree-l1"><a class="reference internal" href="../stdbool/">28. Boolean type and values <tt class="docutils literal"><span class="pre">&lt;stdbool.h&gt;</span></tt></a></li>
<li class="toctree-l1"><a class="reference internal" href="../stddef/">29. Common definitions <tt class="docutils literal"><span class="pre">&lt;stddef.h&gt;</span></tt></a></li>
<li class="toctree-l1"><a class="reference internal" href="../stdint/">30. Integer types <tt class="docutils literal"><span class="pre">&lt;stdint.h&gt;</span></tt></a></li>
<li class="toctree-l1"><a class="reference internal" href="../stdio/">31. Input/output <tt class="docutils literal"><span class="pre">&lt;stdio.h&gt;</span></tt></a></li>
<li class="toctree-l1"><a class="reference internal" href="../stdlib/">32. General utilities <tt class="docutils literal"><span class="pre">&lt;stdlib.h&gt;</span></tt></a></li>
<li class="toctree-l1"><a class="reference internal" href="../string/">33. String handling <tt class="docutils literal"><span class="pre">&lt;string.h&gt;</span></tt></a></li>
<li class="toctree-l1"><a class="reference internal" href="../tgmath/">34. Type-generic math <tt class="docutils literal"><span class="pre">&lt;tgmath.h&gt;</span></tt></a></li>
<li class="toctree-l1"><a class="reference internal" href="../time/">35. Date and time <tt class="docutils literal"><span class="pre">&lt;time.h&gt;</span></tt></a></li>
<li class="toctree-l1"><a class="reference internal" href="../wchar/">36. Extended multibyte and wide character utilities <tt class="docutils literal"><span class="pre">&lt;wchar.h&gt;</span></tt></a></li>
<li class="toctree-l1"><a class="reference internal" href="../wtype/">37. Wide character classification and mapping utilities <tt class="docutils literal"><span class="pre">&lt;wctype.h&gt;</span></tt></a></li>
<li class="toctree-l1"><a class="reference internal" href="../problems/">38. Problems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../license/">39. License</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">3. Console I/O</a><ul>
<li><a class="reference internal" href="#c-s-memory-model">3.1. C&#8217;s Memory Model</a></li>
<li><a class="reference internal" href="#printf">3.2. printf</a></li>
<li><a class="reference internal" href="#conversion-specification">3.3. Conversion Specification</a></li>
<li><a class="reference internal" href="#scanf">3.4. scanf</a></li>
<li><a class="reference internal" href="#character-string-i-o-functions">3.5. Character String I/O Functions</a></li>
<li><a class="reference internal" href="#single-character-i-o">3.6. Single Character I/O</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
                
  <li>
    <a href="../basics/" title="Previous Chapter: 2. Basics of C"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm">&laquo; 2. Basics of C</span>
    </a>
  </li>
  <li>
    <a href="../oae/" title="Next Chapter: 4. Operators and Expressions"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm">4. Operators and... &raquo;</span>
    </a>
  </li>
              
            
            
            
            
              <li class="hidden-sm">
<div id="sourcelink">
  <a href="../_sources/io.txt"
     rel="nofollow">Source</a>
</div></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search/" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12">
      
  <div class="section" id="console-i-o">
<h1>3. Console I/O<a class="headerlink" href="#console-i-o" title="Permalink to this headline">¶</a></h1>
<p>What is I/O? I know you may be wondering what rubbish question? It is
input/output. Well, yes you are right. However, i/o can be further categorized
in several categories. First of them is console i/o, which is what we are
concerned with. In console i/o your keyboard is input device or <tt class="docutils literal"><span class="pre">stdin</span></tt> file
stream and display device or monitor is output device or <tt class="docutils literal"><span class="pre">stdout</span></tt> file stream.
There is also also something called <tt class="docutils literal"><span class="pre">stderr</span></tt> which is standard error file
stream. For historical reasons these are known as <tt class="docutils literal"><span class="pre">FILE</span></tt>, which, happens to be
the data type for handling these streams. Then there are more different kind of
i/o. In everyday usage you use mouse to handle GUI. Standard C99 does not have
anything for mouse. For your hard disk i/o that is real files like our source
code files and executable file same <tt class="docutils literal"><span class="pre">FILE</span></tt> stream is used. Network i/o is also
there. There is an opengroup which specifies functions for network related
functions. Some operating system like GNU/Linux are POSIX compatible which
defines how network i/o will be used. Even a printer is a special output device,
a camera input, speakers output, microphone input and so on. However, before we
go on with i/o I would like to present C&#8217;s memory model which will be needed by
our discussion of i/o related functions. However, if things do not make sense
even then please go through it and come later to understand more.</p>
<div class="section" id="c-s-memory-model">
<span id="index-0"></span><h2>3.1. C&#8217;s Memory Model<a class="headerlink" href="#c-s-memory-model" title="Permalink to this headline">¶</a></h2>
<p>C programs use RAM as primary memory except when you use <tt class="docutils literal"><span class="pre">register</span></tt> keyword to
request compiler to store variables in cpu register. C&#8217;s memory model is split
into three area at a higher level. Data, Stack and Code Segment. Date is further
split in three parts; initialized data segment, uninitialized data segment or
BSS which is name after an ancient assembler Block Started by Symbol and heap.
Initialized data segment contains initialized global variables and static
variables. Here both global and local static variables are counted. For
uninitialized data segment it is same as above just that the variables are not
initialized explicitly but implicitly to zero. Next is heap. Heap is the largest
area of memory used for dynamic memory allocation. As you will see later that
you can manage heap using <tt class="docutils literal"><span class="pre">malloc(),</span> <span class="pre">calloc(),</span> <span class="pre">realloc(),</span></tt> and <tt class="docutils literal"><span class="pre">free()</span></tt>.
Note that compiler does not manage memory allocated for you. You, the
programmer, are responsible for allocating and freeing up memory in area. If
heap gets full os will use virtual memory or swap space on hard disk. Objects
allocated on heap persist across function calls. However, there are some very
nasty problems, which, come in picture when you use heap. There are several of
them. You may forget to allocate memory and want to dereference unallocated
pointer. You may have initialized it to <tt class="docutils literal"><span class="pre">NULL</span></tt> and try to dereference that.
You may allocate and free twice. You forgot to set pointer to <tt class="docutils literal"><span class="pre">NULL</span></tt> after
freeing it. And last but not the least you loose all pointers to the memory area
before you can free. The nature with this particular problem is that if your
program is going to run for long time then it is going to consume more and more
memory. Because of its nature it is known as memory leak. It is very difficult
to detect such problems in code which does not run for long periods of time. Our
friend valgrind will come to help up with this problem. When a memory leak
happens it eats up RAM slowly and then operating system has to use virtual
memory as explained above. In a nutshell, I will say that heap means you have to
handle it.</p>
<p>Stack is relatively simple. All non-static and non-register variables go on
stack. Stack variables do not retain there value across function calls unless
they are passed as pointers. Also, when they go out of scope, that is the scope
in which they were declared ends, they will be kind of lost. The way in which
stack frame moves the same area will be used for new variables. However, stack
is very limited (compared to heap) and in deeply nested function calls or
recursion (you will see these in Functions chapter) stack may get full and
program may crash. The reason for crashing is that operating system will not use
virtual memory but will do a segmentation fault in its place. GNU/Linux allow
its users to modify the stack size by <tt class="docutils literal"><span class="pre">ulimit</span></tt> command. Note that stack and
heap are adjacent in memory and grow in opposite direction.</p>
<p>Code segment or text segment is an area where the executable instructions of
program reside. It is typically constant and read-only area unless your system
allows self-modifying code. Following diagram shows the memory layout.</p>
<a class="reference internal image-reference" href="../_images/memmod.png"><img alt="C's Memory Model" class="align-center" src="../_images/memmod.png" style="width: 107.8px; height: 161.0px;" /></a>
<p>In this chapter we will look at only those functions, which, allow us to do
console i/o. We will begin with our familiar friends. Can you guess who are
they? Yes! They are <tt class="docutils literal"><span class="pre">printf</span></tt> and <tt class="docutils literal"><span class="pre">scanf</span></tt>.</p>
</div>
<div class="section" id="printf">
<span id="index-1"></span><h2>3.2. printf<a class="headerlink" href="#printf" title="Permalink to this headline">¶</a></h2>
<p><tt class="docutils literal"><span class="pre">printf</span></tt> is a string based output function that is It writes character strings
to <tt class="docutils literal"><span class="pre">stdout</span></tt>. The data which has to be written is formatted by format string as
shown previously. After the format specifier it expects as many arguments as
specified in format string. The characters which are not like, say <tt class="docutils literal"><span class="pre">%d</span></tt> for
example, arecalled ordinary characters. These are simply copied to output
stream, which, is <tt class="docutils literal"><span class="pre">stdout</span></tt> for <tt class="docutils literal"><span class="pre">printf</span></tt>. The <tt class="docutils literal"><span class="pre">%d</span></tt> like conversion
charcaters are known as conversion specification or format specifiers. Each
conversion specification should be augmented with one one argument. The results
are undefined if there are insufficient arguments for the format. If extra
arguments are given the excess arguments will be evaluated but are otherwise
ignored. However, there is a big problem here! There is no type-safety.:-( In
general compiler will warn you about it and you, the programmer, are responsible
for giving correct format string, correct no. of correct type of arguments.
Consider the following program for example:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">// printf demo</span>
<span class="c1">// Author: Shiv Shankar Dayal</span>
<span class="c1">// Description: printf demo</span>

<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>

  <span class="c1">//do not mess it. undefined behavior</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>

  <span class="c1">//extra arguments ignored</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="s">&quot;hello&quot;</span><span class="p">);</span>

  <span class="c1">//legal because char is integer type</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="sc">&#39;s&#39;</span><span class="p">);</span>

  <span class="c1">//wrap around of integer as char</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%c</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">836</span><span class="p">);</span>

  <span class="c1">//do not mess with type-safety</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;hello&quot;</span><span class="p">);</span>
  <span class="n">prinf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>now that if you give the command like <tt class="docutils literal"><span class="pre">clang</span> <span class="pre">printf.c</span></tt> then you will be shown following warnings:</p>
<div class="highlight-python"><div class="highlight"><pre>printf.c:12:14: warning: more &#39;%&#39; conversions than data arguments [-Wformat]
        printf(&quot;%d %d\n&quot;, 5);
                 ~^
printf.c:15:26: warning: data argument not used by format string [-Wformat-extra-args]
        printf(&quot;%d %d\n&quot;, 3, 5, &quot;hello&quot;);
             ~~~~~~~~~        ^
printf.c:24:19: warning: conversion specifies type &#39;int&#39; but the argument has type
&#39;char *&#39; [-Wformat]
      int i = printf(&quot;%d\n&quot;, &quot;hello&quot;);
                      ~^     ~~~~~~~
                      %s
3 warnings generated.
</pre></div>
</div>
<p>Clearly this is not a good sign for any program. A program should compile
cleanly. In our case compiler is generating binary even though there are
warnings. You can make compiler generate more warnings by issuing a <tt class="docutils literal"><span class="pre">-Wall</span></tt>
flag. You can also treat all warnings as errors by passing <tt class="docutils literal"><span class="pre">-Werror</span></tt> to
compiler. These two options will ensure that your code has no warnings. Now let
us move to output and try to understand it. The output on my system is as given
below. It may differ on your system:</p>
<div class="highlight-python"><div class="highlight"><pre>3 8
5 8
3 5
115
D
134514119
10
</pre></div>
</div>
<p>First <tt class="docutils literal"><span class="pre">printf</span></tt> is correct as expected. The second line causes undefined
behavior. You may think it is the previous 8 but believe me it is not guaranteed
that it will always the case. Ii is <tt class="docutils literal"><span class="pre">UNDEFINED</span></tt>. Third <tt class="docutils literal"><span class="pre">printf</span></tt> is also fine
in the sense that extra argument is ignored. Fourth and fifth are normal. Sixth
is again a big problem. You are trying to print a decimal integer while argument
is a character string. There is no way for compiler to determine that what
should be printed which will fit on standards. Now we will have to take a look
at all possible format specifier and their meanings. You have seen most of them
so this is more for a reference. I have taken following from
<a class="reference external" href="http://www3.opengroup.org">http://www3.opengroup.org</a> and modified to suit the book. In particular, I have
omitted facts related to XSI specification.</p>
</div>
<div class="section" id="conversion-specification">
<span id="index-2"></span><h2>3.3. Conversion Specification<a class="headerlink" href="#conversion-specification" title="Permalink to this headline">¶</a></h2>
<p>Each conversion specification starts with <tt class="docutils literal"><span class="pre">'%'</span></tt> character. After this
following appear in sequence:</p>
<ul class="simple">
<li>Zero or more flags, in any order, which modify the meaning of the conversion
specification.</li>
<li>An optional minimum field width. If the converted value from argument has
fewer characters (bytes) than the field width, it will be padded with spaces
by default on left; it will be padded on right if the left-adjustment flag
(&#8216;-&#8216;) is given to the field width. The field width takes the form of an
asterisk or a
decimal integer.</li>
<li>An optional precision that gives the minimum number of digits to appear for
the <tt class="docutils literal"><span class="pre">d,</span> <span class="pre">i,</span> <span class="pre">o,</span> <span class="pre">u,</span> <span class="pre">x</span></tt> and <tt class="docutils literal"><span class="pre">X</span></tt> conversion specifiers; the number of digits to
appear for radix character for the <tt class="docutils literal"><span class="pre">a,</span> <span class="pre">A,</span> <span class="pre">e,</span> <span class="pre">E,</span> <span class="pre">f</span></tt> and <tt class="docutils literal"><span class="pre">F</span></tt> conversion
specifiers; the maximum number of significant digits for the <tt class="docutils literal"><span class="pre">g</span></tt> and <tt class="docutils literal"><span class="pre">G</span></tt>
conversion specifiers; or the maximum number of bytes to be printed from a
string in the s conversion specifiers. The precision takes form of a period
(&#8216;.&#8217;) followed either by an asterisk (&#8216;*&#8217;), described below, or an optional
decimal digit string, where a null digit string is treated as zero. If a
precision appears with any other conversion specifier, the behavior is
undefined.</li>
<li>An optional length modifier that specifies the size of the argument.</li>
<li>A conversion specifier character that indicates the type of conversion to be
applied.</li>
</ul>
<p>A field width, or precision, or both, may be indicated by an asterisk(&#8216;*&#8217;). In
this case an argument of type <tt class="docutils literal"><span class="pre">int</span></tt> supplies the field width or precision.
You, the programmer, will have to ensure that arguments specifying field, width
or precision, or both appear in that order before the argument, if any to be
converted. A negative field width is taken as a &#8216;-&#8216; flag followed a positive
field width. A negative precision is taken as if the precision were omitted.</p>
<p>The flag characters and their meanings are:</p>
<p><strong>-</strong> The result of the conversion will be left-justified within the field. The
conversion is right-justified if the flag is not specified.</p>
<p><strong>+</strong> The result of a signed conversion will always begin with a sign (&#8216;+&#8217; or
&#8216;-&#8216;). The conversion will begin with a sign only when a negative value is
converted if this value is not specified.</p>
<p>If the first character of a signed conversion is not a sign or if a signed
conversion results in no characters, a will be prefixed to the result. This
means that if the and &#8216;+&#8217; flags both appear, the flag will be ignored.</p>
<p><strong>#</strong> Specifies that the value is to be converted to an alternative form. For
<tt class="docutils literal"><span class="pre">o</span></tt> conversion, it increases the precision (if necessary) to force the first
digit of the result to be zero. For <tt class="docutils literal"><span class="pre">x</span></tt> or <tt class="docutils literal"><span class="pre">X</span></tt> conversion specifiers, a
non-zero result will have <tt class="docutils literal"><span class="pre">0x</span> <span class="pre">(0X)</span></tt> prefixed to it. For <tt class="docutils literal"><span class="pre">a,</span> <span class="pre">A,</span> <span class="pre">e,</span> <span class="pre">E,</span> <span class="pre">f,</span> <span class="pre">F,</span>
<span class="pre">g</span></tt> and <tt class="docutils literal"><span class="pre">G</span></tt> conversion specifiers, the result will always contain a radix
character, even if no digits follow the radix character. Without this flag, a
radix character appears in the result of these conversions only if a digit
follows it.</p>
<p>For <tt class="docutils literal"><span class="pre">0</span></tt> and <tt class="docutils literal"><span class="pre">G</span></tt> conversion specifiers, trailing zeros will not be removed
from the result as they normally are. For other conversion specifiers the, the
behavior is <tt class="docutils literal"><span class="pre">UNDEFINED</span></tt>.</p>
<p><strong>0</strong> For <tt class="docutils literal"><span class="pre">d,</span> <span class="pre">i,</span> <span class="pre">o,</span> <span class="pre">x,</span> <span class="pre">X,</span> <span class="pre">a,</span> <span class="pre">A,</span> <span class="pre">e,</span> <span class="pre">E,</span> <span class="pre">f,</span> <span class="pre">F,</span> <span class="pre">g</span></tt> and <tt class="docutils literal"><span class="pre">G</span></tt> conversion
specifiers, leading zeros (following any indication of sign or base) are used
to pad to the field width; no space padding is performed. If the &#8216;0&#8217; and &#8216;-&#8216;
flags both appear, the &#8216;0&#8217; flag is ignored. For <tt class="docutils literal"><span class="pre">d,</span> <span class="pre">i,</span> <span class="pre">o,</span> <span class="pre">u,</span> <span class="pre">x</span></tt> and <tt class="docutils literal"><span class="pre">X</span></tt>
conversion specifiers, if a precision is specified, the &#8216;0&#8217; flag is ignored.</p>
<p>The length and their meanings are:</p>
<p><strong>hh</strong> Specifies that a following <tt class="docutils literal"><span class="pre">d,</span> <span class="pre">i,</span> <span class="pre">o,</span> <span class="pre">u,</span> <span class="pre">x</span> <span class="pre">X</span></tt> conversion specifiers
applies to a <tt class="docutils literal"><span class="pre">signed</span> <span class="pre">char</span></tt> or <tt class="docutils literal"><span class="pre">unsigned</span></tt> char argument (the argument will
have been promoted according to integer promotions, but its value will be
converted to) <tt class="docutils literal"><span class="pre">signed</span> <span class="pre">char</span></tt> or <tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">char</span></tt> before printing; or that a
following <tt class="docutils literal"><span class="pre">n</span></tt> conversion specifier applies to a pointer to a <tt class="docutils literal"><span class="pre">signed</span> <span class="pre">char</span></tt>
argument.</p>
<p><strong>h</strong> Specifies that a following <tt class="docutils literal"><span class="pre">d,</span> <span class="pre">i,</span> <span class="pre">o,</span> <span class="pre">u,</span> <span class="pre">x</span></tt> and <tt class="docutils literal"><span class="pre">X</span></tt> conversion
specifier applies to a short or unsigned short argument (the argument will have
been promoted according to the integer promotions, but its value will be
converted to short or unsigned short before printing); or that a following <tt class="docutils literal"><span class="pre">n</span></tt>
conversion specifier applies to a pointer to a <tt class="docutils literal"><span class="pre">short</span></tt> argument.</p>
<p><strong>l</strong> Specifies that a following <tt class="docutils literal"><span class="pre">d,</span> <span class="pre">i,</span> <span class="pre">o,</span> <span class="pre">u,</span> <span class="pre">x</span></tt> and <tt class="docutils literal"><span class="pre">X</span></tt> conversion
specifier applies to a long or unsigned long argument; that a following <tt class="docutils literal"><span class="pre">n</span></tt>
conversion specifier applies to a pointer to a long argument; that a following
c conversion specifier applies to a <tt class="docutils literal"><span class="pre">win_t</span></tt> argument; that a following <tt class="docutils literal"><span class="pre">s</span></tt>
conversion specifier applies to a <tt class="docutils literal"><span class="pre">wchat_t</span></tt> argument; or has not effect on a
following <tt class="docutils literal"><span class="pre">a,</span> <span class="pre">A,</span> <span class="pre">e,</span> <span class="pre">R,</span> <span class="pre">f,</span> <span class="pre">F,</span> <span class="pre">g</span></tt> or <tt class="docutils literal"><span class="pre">G</span></tt> conversion specifier.</p>
<p><strong>ll</strong> Specifies that a following <tt class="docutils literal"><span class="pre">d,</span> <span class="pre">i,</span> <span class="pre">o,</span> <span class="pre">u,</span> <span class="pre">x</span></tt> and <tt class="docutils literal"><span class="pre">X</span></tt> conversion
specifier applies to a long long or unsigned long long argument; that a
following n conversion specifier applies to a pointer to a <tt class="docutils literal"><span class="pre">long</span> <span class="pre">long</span></tt>
argument.</p>
<p><strong>j</strong> Specifies that a following <tt class="docutils literal"><span class="pre">d,</span> <span class="pre">i,</span> <span class="pre">o,</span> <span class="pre">u,</span> <span class="pre">x</span></tt> and <tt class="docutils literal"><span class="pre">X</span></tt> conversion
specifier applies to an <tt class="docutils literal"><span class="pre">intmax_t</span></tt> or <tt class="docutils literal"><span class="pre">uintmax_t</span></tt> argument; or that a
following <tt class="docutils literal"><span class="pre">n</span></tt> conversion specifier applies to an <tt class="docutils literal"><span class="pre">intmax_t</span></tt> argument.</p>
<p><strong>z</strong> Specifies that a following <tt class="docutils literal"><span class="pre">d,</span> <span class="pre">i,</span> <span class="pre">o,</span> <span class="pre">u,</span> <span class="pre">x</span></tt> and <tt class="docutils literal"><span class="pre">X</span></tt> conversion
specifier applies to a <tt class="docutils literal"><span class="pre">size_t</span></tt> or the corresponding signed integer type
argument; or that a following <tt class="docutils literal"><span class="pre">n</span></tt> conversion specifier applies to a signed
integer type corresponding to a <tt class="docutils literal"><span class="pre">size_t</span></tt> argument.</p>
<p><strong>t</strong> Specifies that a following <tt class="docutils literal"><span class="pre">d,</span> <span class="pre">i,</span> <span class="pre">o,</span> <span class="pre">u,</span> <span class="pre">x</span></tt> and <tt class="docutils literal"><span class="pre">X</span></tt> conversion
specifier applies to a <tt class="docutils literal"><span class="pre">ptrdiff_t</span></tt> or the corresponding <tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">int</span></tt> type
argument; or that a following n conversion specifier applies to a unsigned
integer type corresponding to a <tt class="docutils literal"><span class="pre">ptrdiff_t</span></tt> argument.</p>
<p><strong>L</strong> Specifies that a following <tt class="docutils literal"><span class="pre">a,</span> <span class="pre">A,</span> <span class="pre">e,</span> <span class="pre">E,</span> <span class="pre">f,</span> <span class="pre">F,</span> <span class="pre">g</span></tt> and <tt class="docutils literal"><span class="pre">G</span></tt> conversion
specifier applies to a <tt class="docutils literal"><span class="pre">long</span> <span class="pre">double</span></tt> argument.</p>
<p>If a length modifier appears with any conversion specfier other than as specified
above, the behavior is <tt class="docutils literal"><span class="pre">UNDEFINED</span></tt>. You may have noted data types like
<tt class="docutils literal"><span class="pre">intmax_t,</span> <span class="pre">size_t</span></tt> and <tt class="docutils literal"><span class="pre">ptrdiff_t</span></tt>, which you may not know and I have not
told you about them. But do not worry in due course of time we will see them.</p>
<p>The conversion specifiers and their meaning are:</p>
<p><strong>d, i</strong> The <tt class="docutils literal"><span class="pre">int</span></tt> argument will be converted to a signed decimal in the style
&#8220;[-]dddd&#8221;. The precision specifies the minimum number of digits to appear; if
the value being converted can be converted in fewer digits, it will be expanded
with leading zeros. The default precision is 1. The result of converting zero
with an explicit precision of zero will be no characters.</p>
<p><strong>o</strong> The unsigned argument will be converted to unsigned octal format in the
style &#8220;dddd&#8221;. The precision specifies the minimum number of digits to appear;
if the value being converted can be represented in fewer digits, it will be
expanded with leading zeros. The default precision is 1. The result of
converting zero with an explicit precision of zero will be no characters.</p>
<p><strong>u</strong> The unsigned argument will be converted to unsigned decimal format in the
style &#8220;dddd&#8221;. The precision specifies the minimum number of digits to appear; if
the value being converted can be represented in fewer digits, it will be
expanded with leading zeros. The default precision is 1. The result of
converting zero with an explicit precision of zero will be no characters.</p>
<p><strong>x</strong> The unsigned argument will be converted to unsigned decimal format in the
style &#8220;dddd&#8221;; the letters &#8220;abcdef&#8221; are used. The precision specifiers specifies
the minimum number of digits to appear; if the value being converted can be
represented in fewer digits, it will be expanded with leading zeros. The default
precision is 1. The result of converting zero with an explicit precision of zero
will be no characters.</p>
<p><strong>X</strong> Equivalent to the <tt class="docutils literal"><span class="pre">x</span></tt> conversion specifier, except that letters
<tt class="docutils literal"><span class="pre">&quot;ABCDEF&quot;</span></tt> are used instead of <tt class="docutils literal"><span class="pre">&quot;abcdef&quot;</span></tt>.</p>
<p><strong>f, F</strong> The double argument will be converted to decimal notation in the style
&#8220;[-]ddd.ddd&#8221;, where the number of digits after the radix character is equal to
the precision specification. If the precision is missing, it will be taken as 6;
if the precision is explicitly zero and no &#8216;#&#8217; flag is present, no radix
character will appear. If a radix character appears, at least one digit appears
before it. The low-order digit will be rounded in an implementation-defined
manner.</p>
<p><strong>&#8216;</strong> A double argument representing an infinity will be converted in one of the
styles &#8220;[-]inf&#8221; or &#8220;[-]infinity&#8221; ; which style is implementation-defined. A
double argument representing a NaN will be converted in one of the styles
&#8220;[-]nan(n-char-sequence)&#8221; or &#8220;[-]nan&#8221;; which style, and the meaning of any
n-char-sequence, is implementation-defined. The F conversion specifier
produces <tt class="docutils literal"><span class="pre">&quot;INF&quot;,</span> <span class="pre">&quot;INFINITY&quot;</span></tt> or <tt class="docutils literal"><span class="pre">&quot;NAN&quot;</span></tt> instead of <tt class="docutils literal"><span class="pre">&quot;inf&quot;,</span> <span class="pre">&quot;infinity&quot;</span></tt> or
<tt class="docutils literal"><span class="pre">&quot;nan&quot;</span></tt>, respectively.</p>
<p><strong>e, E</strong> The double argument will be converted in the style &#8220;[-]d.ddde[-+]dd&#8221;,
where there is one digit before the radix character (which is non-zero if the
argument is non-zero) and the number of digits after it is equal to the
precision; if the precision is missing, it will be taken as 6; if the precision
is zero and no &#8216;#&#8217; flag is present, no radix character will appear. The
low-order digit will be rounded in an implementation-defined manner. The <tt class="docutils literal"><span class="pre">E</span></tt>
conversion specifier will produce a number with &#8216;E&#8217; instead of &#8216;e&#8217; introducing
the exponent. The exponent will always contain at least two digits. If the value
is zero, the exponent will be zero.</p>
<p>A double argument representing an infinity or NaN will be converted in the style
of an <tt class="docutils literal"><span class="pre">f</span></tt> or <tt class="docutils literal"><span class="pre">F</span></tt> conversion specifier.</p>
<p><strong>g, G</strong> The double argument will be converted in the style <tt class="docutils literal"><span class="pre">f</span></tt> or <tt class="docutils literal"><span class="pre">e</span></tt> (or
in the style <tt class="docutils literal"><span class="pre">F</span></tt> or <tt class="docutils literal"><span class="pre">E</span></tt> in the case of a G conversion specifier), with the
precision specifying the number of significant digits. If an explicit precision
is zero, it will be taken as 1. The style used depends on the value converted;
style <tt class="docutils literal"><span class="pre">e</span></tt> (or <tt class="docutils literal"><span class="pre">E</span></tt> ) will be used only if the exponent resulting from such a
conversion is less than -4 or greater than or equal to the precision. Trailing
zeros will be removed from the fractional portion of the result; a radix
character will appear only if it is followed by a digit or a &#8216;#&#8217; flag is
present.</p>
<p>A double argument representing an infinity or NaN will be converted in the style
of an <tt class="docutils literal"><span class="pre">f</span></tt> or <tt class="docutils literal"><span class="pre">F</span></tt> conversion specifier.</p>
<p><strong>a, A</strong> A double argument representing a floating-point number will be
converted in the style &#8220;[-]0xh.hhhhp(+/-)d&#8221;, where there is one hexadecimal
digit (which will be non-zero if the argument is a normalized floating-point
number and is otherwise unspecified) before the decimal-point character and the
number of hexadecimal digits after it is equal to the precision; if the
precision is missing and <tt class="docutils literal"><span class="pre">FLT_RADIX</span></tt> is a power of 2, then the precision will
be sufficient for an exact representation of the value; if the precision is
missing and <tt class="docutils literal"><span class="pre">FLT_RADIX</span></tt> is not a power of 2, then the precision will be
sufficient to distinguish values of type double, except that trailing zeros may
be omitted; if the precision is zero and the &#8216;#&#8217; flag is not specified, no
decimal-point character will appear. The letters <tt class="docutils literal"><span class="pre">&quot;abcdef&quot;</span></tt> will be used for
<tt class="docutils literal"><span class="pre">a</span></tt> conversion and the letters <tt class="docutils literal"><span class="pre">&quot;ABCDEF&quot;</span></tt> for <tt class="docutils literal"><span class="pre">A</span></tt> conversion. The <tt class="docutils literal"><span class="pre">A</span></tt>
conversion specifier produces a number with &#8216;X&#8217; and &#8216;P&#8217; instead of &#8216;x&#8217; and &#8216;p&#8217;.
The exponent will always contain at least one digit, and only as many more
digits as necessary to represent the decimal exponent of 2. If the value is
zero, the exponent will be zero.</p>
<p>A double argument representing an infinity or NaN will be converted in the style
of an <tt class="docutils literal"><span class="pre">f</span></tt> or <tt class="docutils literal"><span class="pre">F</span></tt> conversion specifier.</p>
<p><strong>c</strong> The int argument will be converted to an unsigned char, and the resulting
byte will be written.</p>
<p>If an <tt class="docutils literal"><span class="pre">l</span></tt> qualifier is present, the <tt class="docutils literal"><span class="pre">wint_t</span></tt> argument will be converted as
if by an ls conversion specification with no precision and an argument that
points to a two-element array of type <tt class="docutils literal"><span class="pre">wchar_t</span></tt>, the first element of which
contains the <tt class="docutils literal"><span class="pre">wint_t</span></tt> argument to the ls conversion specification and the
second element contains a null wide character.</p>
<p><strong>s</strong> The argument will be a pointer to an array of char. Bytes from the array
will be written up to (but not including) any terminating null byte. If the
precision is specified, no more than that many bytes will be written. If the
precision is not specified or is greater than the size of the array, the
programmer will ensure that the array contains a null byte. Note that it is a
big problem which causes strcpy to be insecure. What is the char array does not
have this null terminating character? We will see a safe implementation of
<tt class="docutils literal"><span class="pre">strcpy</span></tt> later. Also, <tt class="docutils literal"><span class="pre">strlen</span></tt> suffers from this problem. Any function
relying on null character will suffer from this. If an <tt class="docutils literal"><span class="pre">l</span></tt> qualifier is
present, the argument will be a pointer to an array of type <tt class="docutils literal"><span class="pre">wchar_t</span></tt>. Wide
characters from the array will be converted to characters (each as if by a call
to the <tt class="docutils literal"><span class="pre">wcrtomb()</span></tt> function, with the conversion state described by an
<tt class="docutils literal"><span class="pre">mbstate_t</span></tt> object initialized to zero before the first wide character is
converted) up to and including a terminating null wide character. The resulting
characters will be written up to (but not including) the terminating null
character (byte). If no precision is specified, the programmer will ensure that
the array contains a null wide character. If a precision is specified, no more
than that many characters (bytes) will be written (including shift sequences, if
any), and the array will contain a null wide character if, to equal the
character sequence length given by the precision, the function would need to
access a wide character one past the end of the array. In no case will a
partial character be written.</p>
<p><strong>p</strong> The argument will be a pointer to <tt class="docutils literal"><span class="pre">void</span></tt>. The value of the pointer is
converted to a sequence of printable characters, in an implementation-defined
manner.</p>
<p><strong>n</strong> The argument will be a pointer to an <tt class="docutils literal"><span class="pre">int</span></tt> into which is written the
number of bytes written to the output so far by this call to one of the
<tt class="docutils literal"><span class="pre">fprintf()</span></tt> functions. No argument is converted.</p>
<p><strong>%</strong> Print a &#8216;%&#8217; character; no argument is converted. The complete conversion
specification will be <tt class="docutils literal"><span class="pre">%%</span></tt>.</p>
<p>If a conversion specification does not match one of the above forms, the
behavior is <tt class="docutils literal"><span class="pre">UNDEFINED</span></tt>. If any argument is not the correct type for the
corresponding conversion specification, the behavior is undefined. This is what
happened to out string in <tt class="docutils literal"><span class="pre">printf.c</span></tt> shown above. In no case will a
nonexistent or small field width cause truncation of a field; if the result of a
conversion is wider than the field width, the field will be expanded to contain
the conversion result. Characters generated by <tt class="docutils literal"><span class="pre">fprintf()</span></tt> and <tt class="docutils literal"><span class="pre">printf()</span></tt>
are printed as if <tt class="docutils literal"><span class="pre">fputc()</span></tt> had been called.</p>
<p>For the <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">A</span></tt> conversion specifiers, if <tt class="docutils literal"><span class="pre">FLT_RADIX</span></tt> is a power of 2,
the value will be correctly rounded to a hexadecimal floating number with the
given precision.</p>
<p>For <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">A</span></tt> conversions, if <tt class="docutils literal"><span class="pre">FLT_RADIX</span></tt> is not a power of 2 and the
result is not exactly representable in the given precision, the result should be
one of the two adjacent numbers in hexadecimal floating style with the given
precision, with the extra stipulation that the error should have a correct sign
for the current rounding direction.</p>
<p>For the <tt class="docutils literal"><span class="pre">e,</span> <span class="pre">E,</span> <span class="pre">f,</span> <span class="pre">F,</span> <span class="pre">g</span></tt> and <tt class="docutils literal"><span class="pre">G</span></tt> conversion specifiers, if the number of
significant decimal digits is at most <tt class="docutils literal"><span class="pre">DECIMAL_DIG</span></tt>, then the result should be
correctly rounded. If the number of significant decimal digits is more than
<tt class="docutils literal"><span class="pre">DECIMAL_DIG</span></tt> but the source value is exactly representable with
<tt class="docutils literal"><span class="pre">DECIMAL_DIG</span></tt> digits, then the result should be an exact representation with
trailing zeros. Otherwise, the source value is bounded by two adjacent decimal
strings <tt class="docutils literal"><span class="pre">L</span> <span class="pre">&lt;</span> <span class="pre">U</span></tt>, both having <tt class="docutils literal"><span class="pre">DECIMAL_DIG</span></tt> significant digits; the value of
the resultant decimal string <tt class="docutils literal"><span class="pre">D</span></tt> should satisfy <tt class="docutils literal"><span class="pre">L</span> <span class="pre">&lt;=</span> <span class="pre">D</span> <span class="pre">&lt;=</span> <span class="pre">U</span></tt>, with the
extra stipulation that the error should have a correct sign for the current
rounding direction.</p>
<p>Some of the capitalized words like <tt class="docutils literal"><span class="pre">DECIMAL_DIG,</span> <span class="pre">FLT_RADIX</span></tt> etc are macros
defined in <tt class="docutils literal"><span class="pre">float.h</span></tt>. You should have a look at it. Now we will have one example
and I will show you output but not explain it. Understanding the output is left
as an exercise to you, the reader.</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">// Format Specifiers</span>
<span class="c1">// Author: Shiv S. Dayal</span>
<span class="o">/</span><span class="n">Desciption</span><span class="o">:</span> <span class="n">It</span> <span class="n">is</span> <span class="n">a</span> <span class="n">demo</span> <span class="n">of</span> <span class="n">several</span> <span class="n">format</span> <span class="n">specifiers</span>

<span class="cp">#include&lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span>   <span class="o">=</span> <span class="mi">343456</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">f</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
  <span class="kt">long</span> <span class="kt">double</span> <span class="n">ld</span> <span class="o">=</span> <span class="mf">78939.9347</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;% d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%+d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%#o</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%#f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%-08i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%08i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%8i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%hhi</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%hi</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%li</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%lli</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%ji</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%zi</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%ti</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%8.8f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%8.8Lf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ld</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>and the output is:</p>
<div class="highlight-python"><div class="highlight"><pre> 343456
+343456
01236640
123.000000
343456
00343456
  343456
-96
15776
343456
4638355772471066016
4638355772471066016
343456
343456
123.00000000
78939.93470000
</pre></div>
</div>
<p>I suggest you to read the desciption of conversion specifiers and experiment
with various parameters to get different kind of output.</p>
</div>
<div class="section" id="scanf">
<span id="index-3"></span><h2>3.4. scanf<a class="headerlink" href="#scanf" title="Permalink to this headline">¶</a></h2>
<p><tt class="docutils literal"><span class="pre">scanf()</span></tt> is sister of <tt class="docutils literal"><span class="pre">printf()</span></tt>. They work in tandem. As its name says
scan function it scans <tt class="docutils literal"><span class="pre">stdin</span></tt> or keyboard for input. Its signature is same
as that of <tt class="docutils literal"><span class="pre">printf()</span></tt>. It raeds bytes from keyboard input, interprets them
according to format string. It also expects a set of pointer arguments as
opposed to values for <tt class="docutils literal"><span class="pre">printf()</span></tt>. The pointers indicate where the interpreted
data from the input will be stored. The result is <tt class="docutils literal"><span class="pre">UNDEFINED</span></tt> if there are
less number of pointer arguments than the number of conversion specifers in
format string. Excess arguments will be evaluated but ignored. The format string
can have only white-space characters or an ordinary character (neither &#8216;%&#8217; nor a
white-space character) or a conversion specification. Each conversion
specification is introduced by &#8216;%&#8217;, after which the following appear in
sequence.</p>
<ul class="simple">
<li>An optoinal assignment suppressing character &#8216;*&#8217;.</li>
<li>An optional non-zero decimal integer that specifies the maximum field width</li>
<li>An option length modifier that specifies the size of the receiving object.</li>
<li>A conversion specifier character that specifies the type of conversion to be
applied. The valid conversion specifiers are described below.</li>
</ul>
<p>A directive composed of one or more white-space characters will be executed by
reading input until no more valid input can be read, or up to the first byte
which is not a white-space character, which remains unread.</p>
<p>A directive that is an ordinary character will be executed as follows: the next
byte will be read from the input and compared with the byte that comprises the
directive; if the comparison shows that they are not equivalent, the directive
will fail, and the differing and subsequent bytes will remain unread. Similarly,
if end-of-file, an encoding error, or a read error prevents a character from
being read, the directive will fail.</p>
<p>A directive that is a conversion specification defines a set of matching input
sequences, as described below for each conversion character. A conversion
specification will be executed in the following steps.</p>
<p>Input white-space characters (as specified by <tt class="docutils literal"><span class="pre">isspace()</span></tt>) will be skipped,
unless the conversion specification includes <tt class="docutils literal"><span class="pre">a</span> <span class="pre">[,</span> <span class="pre">c,</span> <span class="pre">C</span></tt> or <tt class="docutils literal"><span class="pre">n</span></tt> conversion
specifier.</p>
<p>An item will be read from the input, unless the conversion specification
includes an n conversion specifier. An input item will be defined as the longest
sequence of input bytes (up to any specified maximum field width, which may be
measured in characters or bytes dependent on the conversion specifier) which is
an initial subsequence of a matching sequence. The first byte, if any, after the
input item will remain unread. If the length of the input item is 0, the
execution of the conversion specification will fail; this condition is a
matching failure, unless end-of-file, an encoding error, or a read error
prevented input from the stream, in which case it is an input failure.</p>
<p>Except in the case of a <tt class="docutils literal"><span class="pre">%</span></tt> conversion specifier, the input item (or, in the
case of a <tt class="docutils literal"><span class="pre">%n</span></tt> conversion specification, the count of input bytes) will be
converted to a type appropriate to the conversion character. If the input item
is not a matching sequence, the execution of the conversion specification fails;
this condition is a matching failure. Unless assignment suppression was
indicated by a &#8216;*&#8217;, the result of the conversion will be placed in the object
pointed to by the first argument following the format argument that has not
already received a conversion result if the conversion specification is
introduced by <tt class="docutils literal"><span class="pre">%</span></tt>. If this object does not have an appropriate type, or if
the result of the conversion cannot be represented in the space provided, the
behavior is undefined.</p>
<p>The length modifiers and their meanings are:</p>
<p><strong>hh</strong> Specifies that a following <tt class="docutils literal"><span class="pre">d,</span> <span class="pre">i,</span> <span class="pre">o,</span> <span class="pre">u,</span> <span class="pre">x,</span> <span class="pre">X</span></tt> or <tt class="docutils literal"><span class="pre">n</span></tt> conversion
specifier applies to an argument with type pointer to <tt class="docutils literal"><span class="pre">signed</span> <span class="pre">char</span></tt> or
<tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">char</span></tt>.</p>
<p><strong>h</strong> Specifies that a following <tt class="docutils literal"><span class="pre">d,</span> <span class="pre">i,</span> <span class="pre">o,</span> <span class="pre">u,</span> <span class="pre">x,</span> <span class="pre">X</span></tt> or <tt class="docutils literal"><span class="pre">n</span></tt> conversion
specifier applies to an argument with type pointer to <tt class="docutils literal"><span class="pre">short</span></tt> or <tt class="docutils literal"><span class="pre">unsigned</span>
<span class="pre">short</span></tt>.</p>
<p><strong>l</strong> Specifies that a following <tt class="docutils literal"><span class="pre">d,</span> <span class="pre">i,</span> <span class="pre">o,</span> <span class="pre">u,</span> <span class="pre">x,</span> <span class="pre">X</span></tt> or <tt class="docutils literal"><span class="pre">n</span></tt> conversion
specifier applies to an argument with type pointer to long or unsigned long;
that a following <tt class="docutils literal"><span class="pre">a,</span> <span class="pre">A,</span> <span class="pre">e,</span> <span class="pre">E,</span> <span class="pre">f,</span> <span class="pre">F,</span> <span class="pre">g</span></tt> or <tt class="docutils literal"><span class="pre">G</span></tt> conversion specifier applies
to an argument with type pointer to double; or that a following <tt class="docutils literal"><span class="pre">c,</span> <span class="pre">s</span></tt> or
<tt class="docutils literal"><span class="pre">[</span></tt> conversion specifier applies to an argument with type pointer to
<tt class="docutils literal"><span class="pre">wchar_t</span></tt>.</p>
<p><strong>l</strong>
Specifies that a following <tt class="docutils literal"><span class="pre">d,</span> <span class="pre">i,</span> <span class="pre">o,</span> <span class="pre">u,</span> <span class="pre">x,</span> <span class="pre">X</span></tt> or <tt class="docutils literal"><span class="pre">n</span></tt> conversion specifier
applies to an argument with type pointer to <tt class="docutils literal"><span class="pre">long</span> <span class="pre">long</span></tt> or <tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">long</span>
<span class="pre">long</span></tt>.</p>
<p><strong>j</strong>
Specifies that a following <tt class="docutils literal"><span class="pre">d,</span> <span class="pre">i,</span> <span class="pre">o,</span> <span class="pre">u,</span> <span class="pre">x,</span> <span class="pre">X</span></tt> or <tt class="docutils literal"><span class="pre">n</span></tt> conversion specifier
applies to an argument with type pointer to <tt class="docutils literal"><span class="pre">intmax_t</span></tt> or <tt class="docutils literal"><span class="pre">uintmax_t</span></tt>.</p>
<p><strong>z</strong>
Specifies that a following <tt class="docutils literal"><span class="pre">d,</span> <span class="pre">i,</span> <span class="pre">o,</span> <span class="pre">u,</span> <span class="pre">x,</span> <span class="pre">X</span></tt> or <tt class="docutils literal"><span class="pre">n</span></tt> conversion specifier
applies to an argument with type pointer to <tt class="docutils literal"><span class="pre">size_t</span></tt> or the corresponding
<tt class="docutils literal"><span class="pre">signed</span> <span class="pre">int</span></tt> type.</p>
<p><strong>t</strong>
Specifies that a following <tt class="docutils literal"><span class="pre">d,</span> <span class="pre">i,</span> <span class="pre">o,</span> <span class="pre">u,</span> <span class="pre">x,</span> <span class="pre">X</span></tt> or <tt class="docutils literal"><span class="pre">n</span></tt> conversion specifier
applies to an argument with type pointer to <tt class="docutils literal"><span class="pre">ptrdiff_t</span></tt> or the corresponding
<tt class="docutils literal"><span class="pre">unsigned</span></tt> type.</p>
<p><strong>L</strong>
Specifies that a following <tt class="docutils literal"><span class="pre">d,</span> <span class="pre">i,</span> <span class="pre">o,</span> <span class="pre">u,</span> <span class="pre">x,</span> <span class="pre">X</span></tt> or <tt class="docutils literal"><span class="pre">n</span></tt> conversion specifier
applies to an argument with type pointer to <tt class="docutils literal"><span class="pre">long</span> <span class="pre">double</span></tt>.</p>
<p>If a length modifier appears with any conversion specifier other than as
specified above, the bahavior is undefined.
The following conversion specifiers are valid:</p>
<p><strong>d</strong>
Matches an optionally signed decimal integer, whose format is the same as
expected for the subject sequence of <tt class="docutils literal"><span class="pre">strtol()</span></tt> with the value 10 for the base
argument. In the absence of a size modifier, the programmer will ensure that the
corresponding argument is a pointer to <tt class="docutils literal"><span class="pre">int</span></tt>.</p>
<p><strong>i</strong>
Matches an optionally signed integer, whose format is the same as expected for
the subject sequence of <tt class="docutils literal"><span class="pre">strtol()</span></tt> with 0 for the base argument. In the
absence of a size modifier, the programmer will ensure that the corresponding
argument is a pointer to <tt class="docutils literal"><span class="pre">int</span></tt>.</p>
<p><strong>o</strong>
Matches an optionally signed octal integer, whose format is the same as expected
for the subject sequence of <tt class="docutils literal"><span class="pre">strtol()</span></tt> with the value 8 for the base argument.
In the absence of a size modifier, the programmer will ensure that the
corresponding argument is a pointer to <tt class="docutils literal"><span class="pre">unsigned</span></tt>.</p>
<p><strong>u</strong>
Matches an optionally signed decimal integer, whose format is the same as
expected for the subject sequence of <tt class="docutils literal"><span class="pre">strtol()</span></tt> with the value 10 for the base
argument. In the absence of a size modifier, the programmer will ensure that the
corresponding argument is a pointer to <tt class="docutils literal"><span class="pre">unsigned</span></tt>.</p>
<p><strong>x</strong>
Matches an optionally signed decimal integer, whose format is the same as
expected for the subject sequence of <tt class="docutils literal"><span class="pre">strtol()</span></tt> with the value 10 for the base
argument. In the absence of a size modifier, the programmer will ensure that the
corresponding argument is a pointer to <tt class="docutils literal"><span class="pre">unsigned</span></tt>.</p>
<p><strong>a, e, f, g</strong>
Matches an optionally signed floating-point number, infinity, or NaN, whose
format is the same as expected for the subject sequence of <tt class="docutils literal"><span class="pre">strtod()</span></tt>. In the
absence of a size modifier, the programmer will ensure that the corresponding
argument is a pointer to <tt class="docutils literal"><span class="pre">float</span></tt>.</p>
<p>If the <tt class="docutils literal"><span class="pre">printf()</span></tt> family of functions generates character string
representations for infinity and NaN (a symbolic entity encoded in
floating-point format) to support IEEE Std 754-1985, the <tt class="docutils literal"><span class="pre">scanf()</span></tt> family of
functions will recognize them as input.</p>
<p><strong>s</strong>
Matches a sequence of bytes that are not white-space characters. The programmer
will ensure that the corresponding argument is a pointer to the initial byte of
an array (will see them later) of <tt class="docutils literal"><span class="pre">char,</span> <span class="pre">signed</span> <span class="pre">char</span></tt> or <tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">char</span></tt>
large enough to accept the sequence and a terminating null character code, which
will be added automatically.</p>
<p>If an <tt class="docutils literal"><span class="pre">l</span></tt> qualifier is present, the input is a sequence of characters that
begins in the initial shift state. Each character will be converted to a wide
character as if by a call to the <tt class="docutils literal"><span class="pre">mbrtowc()</span></tt> function, with the conversion
state described by an <tt class="docutils literal"><span class="pre">mbstate_t</span></tt> object initialized to zero before the first
character is converted. The programmer will ensure that the corresponding
argument is a pointer to an array of <tt class="docutils literal"><span class="pre">wchar_t</span></tt> large enough to accept the
sequence and the terminating null wide character, which will be added
automatically.</p>
<p><strong>c</strong>
Matches a sequence of bytes of the number specified by the field width (1 if no
field width is present in the conversion specification). The programmer will
ensure that the corresponding argument is a pointer to the initial byte of an
array of <tt class="docutils literal"><span class="pre">char,</span> <span class="pre">signed</span> <span class="pre">char</span></tt> or <tt class="docutils literal"><span class="pre">unsigned</span> <span class="pre">char</span></tt> large enough to accept the
sequence. No null byte is added. The normal skip over white-space characters
will be suppressed in this case.</p>
<p>If an <tt class="docutils literal"><span class="pre">l</span></tt> qualifier is present, the input will be a sequence of characters
that begins in the initial shift state. Each character in the sequence is
converted to a wide character as if by a call to the <tt class="docutils literal"><span class="pre">mbrtowc()</span></tt> function,
with the conversion state described by an <tt class="docutils literal"><span class="pre">mbstate_t</span></tt> object initialized to
zero before the first character is converted. The programmer will ensure that
the corresponding argument is a pointer to an array of <tt class="docutils literal"><span class="pre">wchar_t</span></tt> large enough
to accept the resulting sequence of wide characters. No null wide character is
added.</p>
<p><strong>p</strong>
Matches an implementation-defined set of sequences, which shall be the same as
the set of sequences that is produced by the <tt class="docutils literal"><span class="pre">%p</span></tt> conversion specification of
the corresponding <tt class="docutils literal"><span class="pre">printf()</span></tt> functions. The application shall ensure that the
corresponding argument is a pointer to a pointer to void. The interpretation of
the input item is implementation-defined. If the input item is a value converted
earlier during the same program execution, the pointer that results will compare
equal to that value; otherwise, the behavior of the %p conversion specification
is undefined.</p>
<p><strong>[</strong>
Matches a non-empty sequence of bytes from a set of expected bytes (the
scanset). The normal skip over white-space characters shall be suppressed in
this case. The programmer will ensure that the corresponding argument is a
pointer to the initial byte of an array of <tt class="docutils literal"><span class="pre">char,</span> <span class="pre">signed</span> <span class="pre">char</span></tt> or <tt class="docutils literal"><span class="pre">unsigned</span>
<span class="pre">char</span></tt> large enough to accept the sequence and a terminating null byte, which
shall be added automatically.</p>
<p>If an <tt class="docutils literal"><span class="pre">l</span></tt> qualifier is present, the input is a sequence of characters that
begins in the initial shift state. Each character in the sequence will be
converted to a wide character as if by a call to the <tt class="docutils literal"><span class="pre">mbrtowc()</span></tt> function,
with the conversion state described by an <tt class="docutils literal"><span class="pre">mbstate_t</span></tt> object initialized to
zero before the first character is converted. The programmer will ensure that
the corresponding argument is a pointer to an array of <tt class="docutils literal"><span class="pre">wchar_t</span></tt> large enough
to accept the sequence and the terminating null wide character, which will be
added automatically.</p>
<p>The conversion specification includes all subsequent bytes in the format string
up to and including the matching right square bracket ( &#8216;]&#8217; ). The bytes between
the square brackets (the scanlist) comprise the scanset, unless the byte after
the left square bracket is a circumflex ( &#8216;^&#8217; ), in which case the scanset
contains all bytes that do not appear in the scanlist between the circumflex
and the right square bracket. If the conversion specification begins with &#8220;[]&#8221;
or &#8220;[^]&#8221;, the right square bracket is included in the scanlist and the next
right square bracket is the matching right square bracket that ends the
conversion specification; otherwise, the first right square bracket is the one
that ends the conversion specification. If a &#8216;-&#8216; is in the scanlist and is not
the first character, nor the second where the first character is a &#8216;^&#8217;, nor the
last character, the behavior is implementation-defined.</p>
<p>If a conversion specification is invalid, the behavior is undefined.</p>
<p>The conversion specifiers <tt class="docutils literal"><span class="pre">A,</span> <span class="pre">E,</span> <span class="pre">F,</span> <span class="pre">G</span></tt> and <tt class="docutils literal"><span class="pre">X</span></tt> are also valid and shall be
equivalent to <tt class="docutils literal"><span class="pre">a,</span> <span class="pre">e,</span> <span class="pre">f,</span> <span class="pre">g</span></tt> and <tt class="docutils literal"><span class="pre">x</span></tt> respectively.</p>
<p>If end-of-file is encountered during input, conversion shall be terminated. If
end-of-file occurs before any bytes matching the current conversion
specification (except for <tt class="docutils literal"><span class="pre">%n</span></tt>) have been read (other than leading
white-space characters, where permitted), execution of the current conversion
specification will terminate with an input failure. Otherwise, unless execution
of the current conversion specification is terminated with a matching failure,
execution of the following conversion specification (if any) will be terminated
with an input failure.</p>
<p>Reaching the end of the string in <tt class="docutils literal"><span class="pre">sscanf()</span></tt> shall be equivalent to
encountering end-of-file for <tt class="docutils literal"><span class="pre">scanf()</span></tt>.</p>
<p>If conversion terminates on a conflicting input, the offending input is left
unread in the input. Any trailing white space (including newlines) shall be left
unread unless matched by a conversion specification. The success of literal
matches and suppressed assignments is only directly determinable via the <tt class="docutils literal"><span class="pre">%n</span></tt>
conversion specification.</p>
<p>Time for some code. You have already seen many examples of scanf so I will
just explain some concepts here. Consider the following program:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">// Author: Shiv S. Dayal</span>
<span class="c1">// Description: Demo of string input</span>

<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="mi">128</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

  <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;You entered:</span><span class="se">\n</span><span class="s">%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>and the output is:</p>
<div class="highlight-python"><div class="highlight"><pre>Hi! My name is Shiv.
You entered:
Hi!
</pre></div>
</div>
<p>It is certainly not the corect output. We had expected to see like: &#8220;Hi! My name
is Shiv.&#8221;. What happend to input string after &#8220;Hi!&#8221;. Well, in a form given above
for <tt class="docutils literal"><span class="pre">scanf()</span></tt> it will stop taking input after white-space for character
strings. For numerics it does not matter as it does not match the format. For
characters it is character-by-character so no confusion either. So what if you
want to have the entire string including white-spaces. Use [^n] as given below:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">// Author: Shiv S. Dayal</span>
<span class="c1">// Description: Corrected demo of string input</span>

<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="mi">128</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

  <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%[^</span><span class="se">\n</span><span class="s">]s&quot;</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;You entered:</span><span class="se">\n</span><span class="s">%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>and the output is:</p>
<div class="highlight-python"><div class="highlight"><pre>Hi! My name is Shiv.
You entered:
Hi! My name is Shiv.
</pre></div>
</div>
<p>What if you want to filter a string based on certain patterns. For example, a
charcater string does not contain more that a single space, English alphabets,
period and digits. To scan such a string you can define a pttern as program
given below shows:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">// Author: Shiv. S Dayal</span>
<span class="c1">// Description: Demo of []</span>

<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">c</span><span class="p">[</span><span class="mi">100</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>

  <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%[ A-Za-z0-9!.]&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>and the output is:</p>
<div class="highlight-python"><div class="highlight"><pre>Hi! My name is Shiv! My phone no. is 1234. %^$&amp;*
Hi! My name is Shiv! My phone no. is 1234.
</pre></div>
</div>
<p>There is also a major problem associated with input and that comes when you have
characters involved. Consider the following program:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">// Author: Shiv S. Dayal</span>
<span class="c1">// Description: Demo of scanf() function</span>

<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span>   <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">f</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
  <span class="kt">char</span>  <span class="n">c1</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
  <span class="kt">char</span>  <span class="n">c2</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
  <span class="kt">char</span>  <span class="n">c3</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Enter an integer, a float and three character one by one:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

  <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
  <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%f&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">f</span><span class="p">);</span>
  <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%c&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c1</span><span class="p">);</span>
  <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%c&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c2</span><span class="p">);</span>
  <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%c&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c3</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;You entered</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%c</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c1</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%c</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c2</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%c</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c3</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>and the output is:</p>
<div class="highlight-python"><div class="highlight"><pre>2
3.4
s
You entered
2
3.400000


s
</pre></div>
</div>
<p>What is happening here is that newline entered by our RET key is getting
assigned to <tt class="docutils literal"><span class="pre">c1</span></tt> and <tt class="docutils literal"><span class="pre">c3</span></tt>. That is why the program accepted only second
character. The enter after <tt class="docutils literal"><span class="pre">float</span> <span class="pre">f;</span></tt> was assigned to <tt class="docutils literal"><span class="pre">c1</span></tt> and the character
entered to <tt class="docutils literal"><span class="pre">c2</span></tt> and then the RET newline to <tt class="docutils literal"><span class="pre">c3</span></tt>. There is a very simple way
to recover from this:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">// Author: Shiv S. Dayal</span>
<span class="c1">// Description: Demo of scanf() function</span>

<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span>   <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">f</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
  <span class="kt">char</span>  <span class="n">c1</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
  <span class="kt">char</span>  <span class="n">c2</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
  <span class="kt">char</span>  <span class="n">c3</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Enter an integer, a float and three character one by one:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
  <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%f&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">f</span><span class="p">);</span>
  <span class="n">scanf</span><span class="p">(</span><span class="s">&quot; %c&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c1</span><span class="p">);</span>
  <span class="n">scanf</span><span class="p">(</span><span class="s">&quot; %c&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c2</span><span class="p">);</span>
  <span class="n">scanf</span><span class="p">(</span><span class="s">&quot; %c&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c3</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%c</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c1</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%c</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c2</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%c</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c3</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The whitespace character shown will eat up all the white-space given after the
previous input. This concludes our discussion on <tt class="docutils literal"><span class="pre">printf()</span></tt> and <tt class="docutils literal"><span class="pre">scanf()</span></tt>.
Now we will move to another set of i/o functions which take character string
without filtering and print it to screen without filtering. What I am going to
discuss are <tt class="docutils literal"><span class="pre">gets(),</span> <span class="pre">fgets(),</span> <span class="pre">puts()</span></tt> and <tt class="docutils literal"><span class="pre">fputs()</span></tt>.</p>
</div>
<div class="section" id="character-string-i-o-functions">
<span id="index-4"></span><h2>3.5. Character String I/O Functions<a class="headerlink" href="#character-string-i-o-functions" title="Permalink to this headline">¶</a></h2>
<p>These functions are very simple compared to <tt class="docutils literal"><span class="pre">printf()</span></tt> and <tt class="docutils literal"><span class="pre">scanf()</span></tt>. They
take a pointer to a character array or a character pointer and fill it with
input or print it to monitor. Note that <tt class="docutils literal"><span class="pre">gets()</span></tt> and <tt class="docutils literal"><span class="pre">puts()</span></tt> work only with
<tt class="docutils literal"><span class="pre">stdin</span></tt> and <tt class="docutils literal"><span class="pre">stdout</span></tt> respectively while <tt class="docutils literal"><span class="pre">fgets()</span></tt> and <tt class="docutils literal"><span class="pre">fputs()</span></tt> work
with <tt class="docutils literal"><span class="pre">FILE</span></tt> streams. They can read and write to file streams that is. Here is
a sample program:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">// Author: Shiv S. Dayal</span>
<span class="c1">// Description : Demo of string i/o</span>
<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">cStack</span><span class="p">[</span><span class="mi">1024</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">cHeap</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="mi">1024</span><span class="p">));</span>

  <span class="n">gets</span><span class="p">(</span><span class="n">cStack</span><span class="p">);</span>
  <span class="n">puts</span><span class="p">(</span><span class="n">cStack</span><span class="p">);</span>

  <span class="n">cHeap</span> <span class="o">=</span> <span class="n">fgets</span><span class="p">(</span><span class="n">cHeap</span><span class="p">,</span> <span class="mi">1024</span><span class="p">,</span> <span class="n">stdin</span><span class="p">);</span>
  <span class="n">fputs</span><span class="p">(</span><span class="n">cHeap</span><span class="p">,</span> <span class="n">stdout</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>and the output is:</p>
<div class="highlight-python"><div class="highlight"><pre>Hi!
Hi!
Hello!
Hello!
</pre></div>
</div>
<p>First <tt class="docutils literal"><span class="pre">&quot;Hi!&quot;</span></tt> and <tt class="docutils literal"><span class="pre">&quot;Hello!&quot;</span></tt> are keyboard inputs. Do not worry about array
and pointer syntax at the moment. Just see the difference between function
calls. Their is a problem with <tt class="docutils literal"><span class="pre">gets()</span></tt> that it can cause buffer overflow. If
input is bigger than 1024 bytes including the null terminator then buffer
overflow will happen. Note how you can prevent it with <tt class="docutils literal"><span class="pre">fgets()</span></tt> by specifying
the number of characters you want to read. Rest of input will be ignored by
<tt class="docutils literal"><span class="pre">fgets()</span></tt>. This is a security hole and therefore you should never ever use
<tt class="docutils literal"><span class="pre">gets()</span></tt>.</p>
<p>Time for single character input/output.</p>
</div>
<div class="section" id="single-character-i-o">
<span id="index-5"></span><h2>3.6. Single Character I/O<a class="headerlink" href="#single-character-i-o" title="Permalink to this headline">¶</a></h2>
<p>There are several functions for single character i/o. They are <tt class="docutils literal"><span class="pre">getc(),</span> <span class="pre">putc(),</span>
<span class="pre">getchar(),</span> <span class="pre">putchar(),</span> <span class="pre">fgetc()</span></tt> and <tt class="docutils literal"><span class="pre">fputc()</span></tt>. Apart from <tt class="docutils literal"><span class="pre">getchar()</span></tt> and
<tt class="docutils literal"><span class="pre">putchar()</span></tt> rest can do any FILE stream-based i/o. Let us see them as they are
mostly trivial.</p>
<div class="highlight-c"><div class="highlight"><pre>// Author: Shiv S. Dayal
// Description: Single character funciton demo
#include&lt;stdio.h&gt;

int main()
{
  char c =&#39;&#39;;

  c = getchar();
  putchar(c);

  c = getchar();
  putchar(c);

  c = fgetc(stdin);
  fputc(c, stdout);

  c = getchar();
  putchar(c);

  c = getc(stdin);
  putc(c, stdout);

  return 0;
}
</pre></div>
</div>
<p>and the output is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="mi">4</span>
<span class="mi">4</span>
<span class="mi">5</span>
<span class="mi">5</span>
<span class="mi">6</span>
<span class="mi">6</span>
</pre></div>
</div>
<p>The first 4, 5 and 6 were keyboard inputs. Note the use of extra <tt class="docutils literal"><span class="pre">getchar()</span></tt>
and <tt class="docutils literal"><span class="pre">putchar()</span></tt> to handle the situation we faced during <tt class="docutils literal"><span class="pre">scanf()</span></tt>.</p>
<p>So we have seen many functions and programs for console i/o. File i/o is still
there and will be covered later. This chapter ends here. See you in the next
chapter with operators and expressions.:-)</p>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2012, Shiv S. Dayal.<br/>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.2.<br/>
    </p>
  </div>
</footer>
  </body>
</html>