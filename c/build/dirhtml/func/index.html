<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>7. Functions &mdash; C99  documentation</title>
    
    <link rel="stylesheet" href="../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-3.1.0/css/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-3.1.0/css/bootstrap-theme.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-3.1.0/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-sphinx.js"></script>
    <link rel="top" title="C99  documentation" href="../" />
    <link rel="next" title="8. Structures and Unions" href="../su/" />
    <link rel="prev" title="6. Arrays and Pointers" href="../ap/" />
<script src="../_static/analytics.js" type="text/javascript"></script>
<link rel="stylesheet" href="../../../css/math.css" type="text/css" />

  </head>
  <body>




  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="/">Home</a>
        <a class="navbar-brand" href="../">
          C99</a>
        <span class="navbar-text navbar-version pull-left"><b>0.2</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            <li class="divider-vertical"></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../introduction/">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../basics/">2. Basics of C</a></li>
<li class="toctree-l1"><a class="reference internal" href="../io/">3. Console I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../oae/">4. Operators and Expressions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cf/">5. Control Flow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ap/">6. Arrays and Pointers</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">7. Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../su/">8. Structures and Unions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fs/">9. Following Specification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../env/">10. Environment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lang/">11. Language</a></li>
<li class="toctree-l1"><a class="reference internal" href="../macros/">12. Preprocessing Directives</a></li>
<li class="toctree-l1"><a class="reference internal" href="../std/">13. The C Standard Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../assert/">14. Diagnostics <tt class="docutils literal"><span class="pre">&lt;assert.h&gt;</span></tt></a></li>
<li class="toctree-l1"><a class="reference internal" href="../complex/">15. Complex arithmetic <tt class="docutils literal"><span class="pre">&lt;complex.h&gt;</span></tt></a></li>
<li class="toctree-l1"><a class="reference internal" href="../ctypes/">16. Character Handling <tt class="docutils literal"><span class="pre">&lt;ctype.h&gt;</span></tt></a></li>
<li class="toctree-l1"><a class="reference internal" href="../errno/">17. Errors <tt class="docutils literal"><span class="pre">&lt;errno.h&gt;</span></tt></a></li>
<li class="toctree-l1"><a class="reference internal" href="../fenv/">18. Floating-point environment <tt class="docutils literal"><span class="pre">&lt;fenv.h&gt;</span></tt></a></li>
<li class="toctree-l1"><a class="reference internal" href="../float/">19. Characteristics of floating types <tt class="docutils literal"><span class="pre">&lt;float.h&gt;</span></tt></a></li>
<li class="toctree-l1"><a class="reference internal" href="../inttypes/">20. Format conversion of integer types <tt class="docutils literal"><span class="pre">&lt;inttypes.h&gt;</span></tt></a></li>
<li class="toctree-l1"><a class="reference internal" href="../iso646/">21. Alternative spellings <tt class="docutils literal"><span class="pre">&lt;iso646.h&gt;</span></tt></a></li>
<li class="toctree-l1"><a class="reference internal" href="../limits/">22. Sizes of integer types <tt class="docutils literal"><span class="pre">&lt;limits.h&gt;</span></tt></a></li>
<li class="toctree-l1"><a class="reference internal" href="../locale/">23. Localization &lt;locale.h&gt;</a></li>
<li class="toctree-l1"><a class="reference internal" href="../math/">24. Mathematics <tt class="docutils literal"><span class="pre">&lt;math.h&gt;</span></tt></a></li>
<li class="toctree-l1"><a class="reference internal" href="../setjmp/">25. Nonlocal jumps <tt class="docutils literal"><span class="pre">&lt;setjmp.h&gt;</span></tt></a></li>
<li class="toctree-l1"><a class="reference internal" href="../signal/">26. Signal handling <tt class="docutils literal"><span class="pre">&lt;signal.h&gt;</span></tt></a></li>
<li class="toctree-l1"><a class="reference internal" href="../stdarg/">27. Variable arguments <tt class="docutils literal"><span class="pre">&lt;stdarg.h&gt;</span></tt></a></li>
<li class="toctree-l1"><a class="reference internal" href="../stdbool/">28. Boolean type and values <tt class="docutils literal"><span class="pre">&lt;stdbool.h&gt;</span></tt></a></li>
<li class="toctree-l1"><a class="reference internal" href="../stddef/">29. Common definitions <tt class="docutils literal"><span class="pre">&lt;stddef.h&gt;</span></tt></a></li>
<li class="toctree-l1"><a class="reference internal" href="../stdint/">30. Integer types <tt class="docutils literal"><span class="pre">&lt;stdint.h&gt;</span></tt></a></li>
<li class="toctree-l1"><a class="reference internal" href="../stdio/">31. Input/output <tt class="docutils literal"><span class="pre">&lt;stdio.h&gt;</span></tt></a></li>
<li class="toctree-l1"><a class="reference internal" href="../stdlib/">32. General utilities <tt class="docutils literal"><span class="pre">&lt;stdlib.h&gt;</span></tt></a></li>
<li class="toctree-l1"><a class="reference internal" href="../string/">33. String handling <tt class="docutils literal"><span class="pre">&lt;string.h&gt;</span></tt></a></li>
<li class="toctree-l1"><a class="reference internal" href="../tgmath/">34. Type-generic math <tt class="docutils literal"><span class="pre">&lt;tgmath.h&gt;</span></tt></a></li>
<li class="toctree-l1"><a class="reference internal" href="../time/">35. Date and time <tt class="docutils literal"><span class="pre">&lt;time.h&gt;</span></tt></a></li>
<li class="toctree-l1"><a class="reference internal" href="../wchar/">36. Extended multibyte and wide character utilities <tt class="docutils literal"><span class="pre">&lt;wchar.h&gt;</span></tt></a></li>
<li class="toctree-l1"><a class="reference internal" href="../wtype/">37. Wide character classification and mapping utilities <tt class="docutils literal"><span class="pre">&lt;wctype.h&gt;</span></tt></a></li>
<li class="toctree-l1"><a class="reference internal" href="../problems/">38. Problems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../license/">39. License</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">7. Functions</a><ul>
<li><a class="reference internal" href="#pass-by-value">7.1. Pass-by-value</a></li>
<li><a class="reference internal" href="#pass-by-address">7.2. Pass-by-address</a></li>
<li><a class="reference internal" href="#recursion">7.3. Recursion</a></li>
<li><a class="reference internal" href="#function-like-macros">7.4. Function Like Macros</a></li>
<li><a class="reference internal" href="#inline-functions">7.5. inline Functions</a></li>
<li><a class="reference internal" href="#function-pointers">7.6. Function Pointers</a></li>
<li><a class="reference internal" href="#passing-and-receiving-function-pointers">7.7. Passing and Receiving Function Pointers</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
                
  <li>
    <a href="../ap/" title="Previous Chapter: 6. Arrays and Pointers"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm">&laquo; 6. Arrays and Po...</span>
    </a>
  </li>
  <li>
    <a href="../su/" title="Next Chapter: 8. Structures and Unions"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm">8. Structures an... &raquo;</span>
    </a>
  </li>
              
            
            
            
            
              <li class="hidden-sm">
<div id="sourcelink">
  <a href="../_sources/func.txt"
     rel="nofollow">Source</a>
</div></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search/" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12">
      
  <div class="section" id="functions">
<h1>7. Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h1>
<p>I know that you will readily agree with me if I say that humans get bored if they
have to do same things again and again. I know you get bored too and I too get
bored. We all. We as humans have this built-in nature that repititive things are
just not fit for us. Also, as a human being our capacity to understand large
things at once is difficult. We understand small-small things and build large
chunk based on those small things. Dennis Ritchie perhaps had known this. I am
saying because C has got something called functions. C functions allow you to
split a big logic into small ones and therefore facilitating modular programming.
They also form the basis of strutctured programming the very base which made C
popular. There is also something called recursion which is a very poewrful tool.
In this chapter we will also see how to do multifile programming. I cannot
emphasize much that how important it is that you master the technique of
functions well and not to mention function pointers which can do the magic. I
will show you the very glimpse only. I can show you the way but walking on that
is your job. It is upto you to do the actual work. I have kept things simple and
minimal with a pupose. I do not want you to get bogged down with a thick and
heavy book. All my examples are toy examples but you have seen things can get
somehwat complex.</p>
<p>We have already seen the special <tt class="docutils literal"><span class="pre">main()</span></tt> function.</p>
<div class="section" id="pass-by-value">
<span id="index-0"></span><h2>7.1. Pass-by-value<a class="headerlink" href="#pass-by-value" title="Permalink to this headline">¶</a></h2>
<p>Here I am going to present skeleton of a function prototype and body.
Consider:</p>
<div class="highlight-python"><div class="highlight"><pre>//function prototype
return-type function-name(argument list); //here varible names may be ommitted

//function body
return-type function-name(argument list) //variable names cannot be ommitted``
{
  //your code here

  //call some other function
  function-name(arugment-list-without-type);

  return value-of-return-type;
}
</pre></div>
</div>
<p>This might be a bit abstract but please bear it a bit. In due course of time it
will become clear. You will be able to see in its concrete forms soon. Consider
a program which adds two numbers and let us say that you may need to add lots of
them.</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">//Author: Shiv S. Dayal</span>
<span class="c1">//Description: Demo of function</span>

<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">firstInt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">secondInt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d+%d=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">firstInt</span><span class="p">,</span> <span class="n">secondInt</span><span class="p">,</span> <span class="n">firstInt</span><span class="o">+</span><span class="n">secondInt</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">7</span><span class="p">;</span>

  <span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>output:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="mi">5</span><span class="o">+</span><span class="mi">7</span><span class="o">=</span><span class="mi">12</span>
</pre></div>
</div>
<p>Note that you need function body before its use else you need at least a function
prototype before use. If you do not do so you will get a compiler warnign. An
example is given below:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">//Author: Shiv S. Dayal</span>
<span class="c1">//Description: Demo of function</span>

<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="c1">//not how argument names are not required</span>
<span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">7</span><span class="p">;</span>

  <span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">firstInt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">secondInt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d+%d=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">firstInt</span><span class="p">,</span> <span class="n">secondInt</span><span class="p">,</span> <span class="n">firstInt</span><span class="o">+</span><span class="n">secondInt</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>output is same as above.</p>
<p>What you have seen just above is known as pass-by-value. In this case a copy of
parameters is made and passed on to called function by caller function. So, if
called function makes a change to values then those are not reflected back in
the caller function. As an example I will use famous example of swapping values
of two variables. First, I will show how pass-by-value works. So here is the
code:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">//Author: Shiv S. Dayal</span>
<span class="c1">//Description: Demo of function</span>

<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">7</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Before swap a=%d and b=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
  <span class="n">swap</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;After swap a=%d and b=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kt">int</span> <span class="n">firstArg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">secondArg</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">temp</span><span class="o">=</span><span class="n">firstArg</span><span class="p">;</span>
  <span class="n">firstArg</span><span class="o">=</span><span class="n">secondArg</span><span class="p">;</span>
  <span class="n">secondArg</span><span class="o">=</span><span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>output:</p>
<div class="highlight-python"><div class="highlight"><pre>Before swap a=5 and b=7
After swap a=5 and b=7
</pre></div>
</div>
</div>
<div class="section" id="pass-by-address">
<span id="index-1"></span><h2>7.2. Pass-by-address<a class="headerlink" href="#pass-by-address" title="Permalink to this headline">¶</a></h2>
<p>Not exactly what we wanted. The solution is to pass-by-address. When you the
address to a called function, it receives address in a pointer variable. Then if
it modifies the value stored at that address then it is reflected back in the
caller. Let us see an example to understand:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">//Author: Shiv S. Dayal</span>
<span class="c1">//Description: Demo of function</span>

<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">7</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Before swap a=%d and b=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
  <span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;After swap a=%d and b=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">firstArg</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">secondArg</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">temp</span><span class="o">=*</span><span class="n">firstArg</span><span class="p">;</span>
  <span class="o">*</span><span class="n">firstArg</span><span class="o">=*</span><span class="n">secondArg</span><span class="p">;</span>
  <span class="o">*</span><span class="n">secondArg</span><span class="o">=</span><span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>output:</p>
<div class="highlight-python"><div class="highlight"><pre>Before swap a=5 and b=7
After swap a=7 and b=5
</pre></div>
</div>
</div>
<div class="section" id="recursion">
<span id="index-2"></span><h2>7.3. Recursion<a class="headerlink" href="#recursion" title="Permalink to this headline">¶</a></h2>
<p>In C recusion is the concept of a function calling itself. When a repeated
operation has to be preformed over a variable, recursion can be used. Recursion
simplifies the code a lot. Typically there is always a more effective iterative
solutions are available but there are certain cases where recursion is always
better than iteration. For example, traversal of trees where iteration is not so
effective as compared to recursion. The first example I am going to give is that
of factorials. The formula for factorial is given by <span class="math">\(n!=\prod_{k=1}^n k\)</span>
and recursive definition of factorial is given by:</p>
<div class="math" id="index-3">
\[\begin{split}n!=\left\{\begin{array}{ll}
1 &amp; \quad\text{if n=0}\\
(n-1)!*n  &amp; \quad\text{if n&gt;0}
\end{array}\right.\end{split}\]</div>
<p>Note that every recursion has to be written carefully in thse sense that it must
have a termination condition and that in all the cases the termination condition
must be reached. If a recursion is too deep or infinite there will be a stack
overlow and the program will terminate. First, I will show you an iterative
version with a function.</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">//Author: Shiv S. Dayal</span>
<span class="c1">//Description: Iterative factorial.</span>

<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">long</span> <span class="kt">long</span> <span class="nf">fact</span><span class="p">(</span><span class="kt">int</span> <span class="n">input</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">input</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Enter a number whose input has to be computed:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">input</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Factorial of %d is %lld.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">input</span><span class="p">,</span> <span class="n">fact</span><span class="p">(</span><span class="n">input</span><span class="p">));</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">long</span> <span class="kt">long</span> <span class="nf">fact</span><span class="p">(</span><span class="kt">int</span> <span class="n">input</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">long</span> <span class="kt">long</span> <span class="n">output</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="n">input</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">output</span><span class="o">*=</span><span class="n">input</span><span class="p">;</span>
    <span class="n">input</span><span class="o">--</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">output</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>output:</p>
<div class="highlight-python"><div class="highlight"><pre>Enter a number whose factorial has to be computed:
17
Factorial of 17 is 355687428096000.
</pre></div>
</div>
<p>Now we will see recursive version:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">//Author: Shiv S. Dayal</span>
<span class="c1">//Description: Recursive factorial.</span>

<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">long</span> <span class="kt">long</span> <span class="nf">fact</span><span class="p">(</span><span class="kt">int</span> <span class="n">input</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">input</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Enter a number whose factorial has to be computed:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">input</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Factorial of %d is %lld.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">input</span><span class="p">,</span> <span class="n">fact</span><span class="p">(</span><span class="n">input</span><span class="p">));</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">long</span> <span class="kt">long</span> <span class="nf">fact</span><span class="p">(</span><span class="kt">int</span> <span class="n">input</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="n">input</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="n">fact</span><span class="p">(</span><span class="n">input</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">input</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>output:</p>
<div class="highlight-python"><div class="highlight"><pre>Enter a number whose factorial has to be computed:
16
Factorial of 16 is 20922789888000.
</pre></div>
</div>
<p>Recursion is very simple yet may be very deceptive to understand for beginners.
Let us dissect the code. Our input was 16 so if will not match and <tt class="docutils literal"><span class="pre">return</span>
<span class="pre">fact(15)*16;</span></tt> will be executed. Here, before <tt class="docutils literal"><span class="pre">fact(16)</span></tt> can return
<tt class="docutils literal"><span class="pre">fact(15)</span></tt> has to return. And, similarly before <tt class="docutils literal"><span class="pre">fact(15)</span></tt> can return
<tt class="docutils literal"><span class="pre">fact(14)</span></tt> has to return. Now, note that for <tt class="docutils literal"><span class="pre">fact(0)</span></tt> there is no such
condition and it can return 1 making it possible for <tt class="docutils literal"><span class="pre">fact(1)</span></tt> to return,
which, in turn will make it posiible for <tt class="docutils literal"><span class="pre">fact(2)</span></tt> to return and so on. So,
what is happening is function is calling itself by creating more and more
function frames and when the termination condition reaches the stack unwinds.</p>
<p id="index-4">Let us consider one more famous example for recursive function, that is of
computing Fibonacci numbers. The Fibonacci series is given by:</p>
<div class="math">
\[F_n = F_{n-1} + F_{n-2}\]</div>
<p>where first two numebrs are given by:</p>
<div class="math">
\[F_0 = 0  \text{ and }  F_1 = 1\]</div>
<p>First consider the iterative version:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">//Author: Shiv S. Dayal</span>
<span class="c1">//Description: Iterative Fibonacci series.</span>

<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">void</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="kt">int</span> <span class="n">input</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">input</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;How many Fibonacci numbers you want?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">input</span><span class="p">);</span>

  <span class="n">fibonacci</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="n">input</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">fib0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">fib1</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>

  <span class="k">if</span><span class="p">(</span><span class="n">input</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
  <span class="k">return</span><span class="p">;</span>
  <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">input</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fib0</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">input</span><span class="o">==</span><span class="mi">2</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fib0</span><span class="p">,</span> <span class="n">fib1</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">input</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d %d&quot;</span><span class="p">,</span> <span class="n">fib0</span><span class="p">,</span> <span class="n">fib1</span><span class="p">);</span>
    <span class="k">while</span><span class="p">(</span><span class="n">input</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">fib1</span><span class="o">=</span><span class="n">fib1</span><span class="o">+</span><span class="n">fib0</span><span class="p">;</span>
      <span class="n">fib0</span><span class="o">=</span><span class="n">fib1</span><span class="o">-</span><span class="n">fib0</span><span class="p">;</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&quot; %d&quot;</span><span class="p">,</span> <span class="n">fib1</span><span class="p">);</span>
      <span class="n">input</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>output:</p>
<div class="highlight-python"><div class="highlight"><pre>How many Fibonacci numbers you want?
16
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
</pre></div>
</div>
<p>Now we will see recursive version:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">//Author: Shiv S. Dayal</span>
<span class="c1">//Description: iRecursive Fibonacci series.</span>

<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">long</span> <span class="kt">long</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="kt">int</span> <span class="n">input</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">input</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Which Fibonacci number you want?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">input</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%lld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">input</span><span class="p">));</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">long</span> <span class="kt">long</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="kt">int</span> <span class="n">input</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">long</span> <span class="kt">long</span> <span class="n">fib0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">fib1</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>

  <span class="k">if</span><span class="p">(</span><span class="n">input</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">fib0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">input</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">fib1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">fib</span> <span class="o">=</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">input</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">fibonacci</span><span class="p">(</span><span class="n">input</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">fib</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>output:</p>
<div class="highlight-python"><div class="highlight"><pre>Which Fibonacci number you want?
32
2178309
</pre></div>
</div>
</div>
<div class="section" id="function-like-macros">
<span id="index-5"></span><h2>7.4. Function Like Macros<a class="headerlink" href="#function-like-macros" title="Permalink to this headline">¶</a></h2>
<p>Functions are costly if they are very small. For example, let us say we want to
add two integers only then it does not make sense to write a function. When you
call a function a new function frame has to be created, new variables are
created, when function returns things are cleaned and return value is returned.
All this consume memory and CPU cycles so old C style was to use macros. For
example, consider following program:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">//Author: Shiv S. Dayal</span>
<span class="c1">//Description: Demo of macros.</span>

<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="cp">#define SUM(a, b) a+b</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">SUM</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="n">SUM</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">));</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>output:</p>
<div class="highlight-python"><div class="highlight"><pre>12 17
</pre></div>
</div>
<p>However, such usage of macros are inappropriate, dangerous and higly adivised
against. First you have to take care that you parenthesize all parameters
carefully. Even then consider following:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#define MIN(a,b)  ((a)&lt;(b))?(a):(b);</span>
</pre></div>
</div>
<p>If it get a call like:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">3</span><span class="p">;</span>
<span class="n">MIN</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="o">++</span><span class="n">b</span><span class="p">)</span><span class="c1">//then macro will expand to</span>
<span class="p">((</span><span class="n">a</span><span class="p">)</span><span class="o">&lt;</span><span class="p">(</span><span class="o">++</span><span class="n">b</span><span class="p">))</span><span class="o">?</span><span class="p">(</span><span class="n">a</span><span class="p">);(</span><span class="o">++</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
<p>Now since <tt class="docutils literal"><span class="pre">b</span></tt> is less than <tt class="docutils literal"><span class="pre">a</span></tt> it will be incremented twice otherwise it will
be incremented once. Such behavior is confusing at best. Older C programmers had
no choice but only macros. But with new C99 standard we have something called
inline functions. New C99 programmers have no excuse for writing macros like
shown above.</p>
</div>
<div class="section" id="inline-functions">
<span id="index-6"></span><h2>7.5. inline Functions<a class="headerlink" href="#inline-functions" title="Permalink to this headline">¶</a></h2>
<p><tt class="docutils literal"><span class="pre">inline</span></tt> functions are somewhat a mix of macros and functions. It is a request
to compiler to expand the code inline like macros while maintaining the
type-safety of functions. Note that it is a request not a command. Compilers may
choose to ignore the request of inline expansion of code if the inline function
is too complicated. Also, recursive functions are not inlined. You should use
inline functions to replace small functions only. The reasons are being that you
may get problems mentioned in Item 33 of &#8220;Effective C++&#8221; by Scott Meyers. For
smaller functions you have a much higher chance of getting your functions
inlined. To use the inline function you just need to prefix the function
signature and prototype declaration with keyword inline. For smaller functions
code generated for inline functions will outweigh the overhead which is there
for function calls. However, if you inline too much the size of your binary will
become bigger and bigger and it may be a problem on systems; straved for memory;
in systems like embedded systems. Typically inline functoins are declared in
headers so that all source files can benefit from it. However, this may cause
problems if functions are not inlined by compiler.</p>
</div>
<div class="section" id="function-pointers">
<span id="index-7"></span><h2>7.6. Function Pointers<a class="headerlink" href="#function-pointers" title="Permalink to this headline">¶</a></h2>
<p>These are very powerful but have got somewhat complex syntax. Due to their
complex syntax programmers typically shun them. However, they are must if you
want to do certain stuff which C typically does not allow, like, object oriented
programming, generic programming, switch/if statement replacement etc. to name a
few. New programmers may wonder how can we have pointers to functions as they are
not variables. Well they are not varibles that I agree but still their addresses
can be taken. However, their addresses lie in code segment or text segment which
happens to be read-only area, hence, that address cannot be modified. Let us
consider a program of a desk calculator with four operations. Addition,
subtraction, multiplication and division. As a typical desk calculator I will
take double as data type as it has sufficient range and precision. How would
you write such a program? Well with our current knowledge we can write four
functions for four operations. Then we can use a switch for choosing the
function. Let us see it in action:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">//Author: Shiv S. Dayal</span>
<span class="c1">//Description: Demo of function pointers.</span>

<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">op</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">op1</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span><span class="n">op2</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span><span class="n">result</span><span class="o">=</span><span class="mf">0.0</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Enter operation (should be one of + - * /):&quot;</span><span class="p">);</span>
  <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%c&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op</span><span class="p">);</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Enter two operands separated by a space:&quot;</span><span class="p">);</span>
  <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%lf %lf&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op2</span><span class="p">);</span>

  <span class="k">switch</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">case</span> <span class="sc">&#39;+&#39;</span>:
      <span class="n">result</span> <span class="o">=</span> <span class="n">op1</span> <span class="o">+</span> <span class="n">op2</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="sc">&#39;-&#39;</span>:
      <span class="n">result</span> <span class="o">=</span> <span class="n">op1</span> <span class="o">-</span> <span class="n">op2</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="sc">&#39;*&#39;</span>:
      <span class="n">result</span> <span class="o">=</span> <span class="n">op1</span> <span class="o">*</span> <span class="n">op2</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="sc">&#39;/&#39;</span>:
      <span class="n">result</span> <span class="o">=</span> <span class="n">op1</span> <span class="o">/</span> <span class="n">op2</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="nl">default:</span>
      <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%lf%c%lf=%lf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">op1</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">op2</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>and the output is:</p>
<div class="highlight-python"><div class="highlight"><pre>Enter operation (should be one of + - * /):+
Enter two operands separated by a space: 2.4 1.2
2.400000+1.200000=3.600000
</pre></div>
</div>
<p>As you can see depending on the operation the switch statement performs the
operation on two operands. We can use function pointers to replace this swiccth
statement:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">//Author: Shiv S. Dayal</span>
<span class="c1">//Description: Demo of function pointers.</span>

<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cm">/* Since there are four arithmetic operations we need four function pointers.*/</span>

<span class="kt">float</span> <span class="nf">plus</span><span class="p">(</span><span class="kt">double</span> <span class="n">op1</span><span class="p">,</span> <span class="kt">double</span> <span class="n">op2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">result</span><span class="o">=</span><span class="mf">0.0</span><span class="p">;</span>

  <span class="n">result</span><span class="o">=</span><span class="n">op1</span><span class="o">+</span><span class="n">op2</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%lf+%lf=%lf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">float</span> <span class="nf">minus</span><span class="p">(</span><span class="kt">double</span> <span class="n">op1</span><span class="p">,</span> <span class="kt">double</span> <span class="n">op2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">result</span><span class="o">=</span><span class="mf">0.0</span><span class="p">;</span>

  <span class="n">result</span><span class="o">=</span><span class="n">op1</span><span class="o">-</span><span class="n">op2</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%lf-%lf=%lf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">float</span> <span class="nf">multiply</span><span class="p">(</span><span class="kt">double</span> <span class="n">op1</span><span class="p">,</span> <span class="kt">double</span> <span class="n">op2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">result</span><span class="o">=</span><span class="mf">0.0</span><span class="p">;</span>

  <span class="n">result</span><span class="o">=</span><span class="n">op1</span><span class="o">*</span><span class="n">op2</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%lf*%lf=%lf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">float</span> <span class="nf">divide</span><span class="p">(</span><span class="kt">double</span> <span class="n">op1</span><span class="p">,</span> <span class="kt">double</span> <span class="n">op2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">result</span><span class="o">=</span><span class="mf">0.0</span><span class="p">;</span>

  <span class="n">result</span><span class="o">=</span><span class="n">op1</span><span class="o">/</span><span class="n">op2</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%lf/%lf=%lf</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">call_fp</span><span class="p">(</span><span class="kt">double</span> <span class="n">op1</span><span class="p">,</span> <span class="kt">double</span> <span class="n">op2</span><span class="p">,</span> <span class="kt">float</span> <span class="p">(</span><span class="o">*</span><span class="n">pt2Func</span><span class="p">)(</span><span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="p">))</span>
<span class="p">{</span>
  <span class="n">pt2Func</span><span class="p">(</span><span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Execute example code</span>
<span class="kt">void</span> <span class="nf">Switch</span><span class="p">(</span><span class="kt">double</span> <span class="n">op1</span><span class="p">,</span> <span class="kt">double</span> <span class="n">op2</span><span class="p">,</span> <span class="kt">char</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">switch</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">case</span> <span class="sc">&#39;+&#39;</span>:
      <span class="n">call_fp</span><span class="p">(</span><span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">plus</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="sc">&#39;-&#39;</span>:
      <span class="n">call_fp</span><span class="p">(</span><span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">minus</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="sc">&#39;*&#39;</span>:
      <span class="n">call_fp</span><span class="p">(</span><span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">multiply</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="sc">&#39;/&#39;</span>:
      <span class="n">call_fp</span><span class="p">(</span><span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">divide</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="nl">default:</span>
      <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">op</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">op1</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">op2</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">result</span><span class="o">=</span><span class="mf">0.0</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Enter operation (should be one of + - * /):&quot;</span><span class="p">);</span>
  <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%c&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Enter two operands separated by a space:&quot;</span><span class="p">);</span>
  <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%lf %lf&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op2</span><span class="p">);</span>

  <span class="n">Switch</span><span class="p">(</span><span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">,</span> <span class="n">op</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>output:</p>
<div class="highlight-python"><div class="highlight"><pre>Enter operation (should be one of + - * /):+
Enter two operands separated by a space:2.4
1.2
2.400000+1.200000=3.600000
</pre></div>
</div>
<p>So you see how a <tt class="docutils literal"><span class="pre">switch</span></tt> statement can be replaced with function pointers. The
abstract declaration of a function pointer is given below:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">return_type</span> <span class="p">(</span><span class="o">*</span><span class="n">function_name</span><span class="p">)(</span><span class="n">arguments</span><span class="p">);</span>
</pre></div>
</div>
<p>You can call these functions in two ways:</p>
<div class="highlight-python"><div class="highlight"><pre>function_name(arguments); //shortcut call
(*function_name)(arguments); //long and correct call
</pre></div>
</div>
<p>You should always prefer the second version as it is more portable across
different compilers and environments.</p>
</div>
<div class="section" id="passing-and-receiving-function-pointers">
<span id="index-8"></span><h2>7.7. Passing and Receiving Function Pointers<a class="headerlink" href="#passing-and-receiving-function-pointers" title="Permalink to this headline">¶</a></h2>
<p>You have already seen how to pass a function pointer as an argument to a second
function in the above exercise. <tt class="docutils literal"><span class="pre">call_fp(op1,op2,</span> <span class="pre">&amp;plus);</span></tt> is where you pass
a function pointer and <tt class="docutils literal"><span class="pre">void</span> <span class="pre">call_fp(doubleop1,</span> <span class="pre">double</span> <span class="pre">op2,</span> <span class="pre">float</span>
<span class="pre">(*pt2Func)(double,</span> <span class="pre">double))</span></tt> is where you receive it as an argument.</p>
<p>You can also return a function pointer from some function. Consider the
following:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">return_type</span> <span class="p">(</span><span class="o">*</span><span class="n">func1</span><span class="p">(</span><span class="n">arguments1</span><span class="p">))(</span><span class="n">arguments2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="n">func2</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This piece of code is a function whose name is <tt class="docutils literal"><span class="pre">func1</span></tt>, it takes <tt class="docutils literal"><span class="pre">arguments1</span></tt>
as its arguments and returns <tt class="docutils literal"><span class="pre">float</span></tt>. The return value is a function pointer
<tt class="docutils literal"><span class="pre">func2</span></tt> whose arguments are <tt class="docutils literal"><span class="pre">arguments2</span></tt>. However, this kind of declaration
is messy and hard to read so we have a solution which makes things easier on us.
Consider a following <tt class="docutils literal"><span class="pre">typedef</span></tt> and function signature:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">typedef</span> <span class="nf">return_type</span> <span class="p">(</span><span class="o">*</span><span class="n">function1</span><span class="p">)(</span><span class="n">arguments</span><span class="p">);</span>
<span class="n">function1</span> <span class="nf">function2</span><span class="p">(</span><span class="n">arguments</span><span class="p">);</span>
</pre></div>
</div>
<p>This is much simpler and cleaner. It is also easier to understand than above.</p>
<p>Similarly you can declare an array of function pointers. This offers the feature
of selection of a function using an index. For example, the menu bar of most of
the GUI programns can be accessed using this. Similarly, there are two ways again
to declare the array of function pointers. The first one is without using typedef
and second one is using <tt class="docutils literal"><span class="pre">typedef</span></tt>. The choice is yours that which one you want
to use. I prefer the <tt class="docutils literal"><span class="pre">typedef</span></tt> version. The syntax is given below:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">typedef</span> <span class="nf">return_type</span> <span class="p">(</span><span class="o">*</span><span class="n">function1</span><span class="p">)(</span><span class="n">arguments</span><span class="p">);</span>
<span class="n">function1</span> <span class="n">array_of_fp</span><span class="p">[</span><span class="n">MAX</span><span class="p">];</span>

<span class="n">return_type</span> <span class="p">(</span><span class="o">*</span><span class="n">function2</span><span class="p">[</span><span class="n">MAX</span><span class="p">])(</span><span class="n">arguments</span><span class="p">);</span>
</pre></div>
</div>
<p>One of the more clever usage of function pointers can be found in the library
function <tt class="docutils literal"><span class="pre">qsort</span></tt> where you have to write the comparison function which is a
callback function. Given below os the signature of qsort function.</p>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">qsort</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">comp</span><span class="p">)</span> <span class="p">(</span>
            <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span> <span class="p">)</span> <span class="p">);</span>
</pre></div>
</div>
<p>The brief description is given here. Sorts the count elements of the array
pointed by <tt class="docutils literal"><span class="pre">a</span></tt>, each element <tt class="docutils literal"><span class="pre">size</span></tt> bytes long, using the compa function to
determine the order.</p>
<p>The sorting algorithm used by this function compares pairs of values by calling
the specified comparator function with two pointers to elements of the array.</p>
<p>The function does not return any value, but modifies the content of the array
pointed by base reordering its elements to the newly sorted order.
Let us see an example:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">//Author: Shiv S. Dayal</span>
<span class="c1">//Description: Demo of qsort.</span>

<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>

<span class="kt">int</span> <span class="n">values</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">25</span> <span class="p">};</span>

<span class="kt">int</span> <span class="nf">compare</span> <span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">a</span> <span class="o">-</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">b</span> <span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

  <span class="n">qsort</span> <span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="n">compare</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">n</span><span class="o">&lt;</span><span class="mi">9</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span>
    <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span><span class="n">values</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>and the output is:</p>
<div class="highlight-python"><div class="highlight"><pre>1 3 4 4 7 10 9 20 25
</pre></div>
</div>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2012, Shiv S. Dayal.<br/>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.2.<br/>
    </p>
  </div>
</footer>
  </body>
</html>