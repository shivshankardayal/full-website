

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-17487464-6']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>1. Introduction &mdash; Data Structures &amp; Algorithms 0.1 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Data Structures &amp; Algorithms 0.1 documentation" href="../"/>
        <link rel="next" title="2. Linear Structures" href="../ls/"/>
        <link rel="prev" title="Data structures and Algorithms Contents" href="../"/>
<link rel="stylesheet" href="../../css/math.css" type="text/css" />


  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../" class="icon icon-home"> Data Structures & Algorithms
          

          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search/" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="">1. Introduction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#problem-to-solution">1.1. Problem to Solution</a></li>
<li class="toctree-l2"><a class="reference internal" href="#preliminaries">1.2. Preliminaries</a></li>
<li class="toctree-l2"><a class="reference internal" href="#efficiency">1.3. Efficiency</a></li>
<li class="toctree-l2"><a class="reference internal" href="#examples-of-asymptotic-complexity-computation">1.4. Examples of Asymptotic Complexity Computation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#simplicity">1.5. Simplicity</a></li>
<li class="toctree-l2"><a class="reference internal" href="#problems-on-complexity">1.6. Problems on Complexity</a></li>
<li class="toctree-l2"><a class="reference internal" href="#mathematical-induction">1.7. Mathematical Induction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#some-basic-mathematics">1.8. Some Basic Mathematics</a></li>
<li class="toctree-l2"><a class="reference internal" href="#algorithms-and-adt-implementation">1.9. Algorithms and ADT Implementation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../ls/">2. Linear Structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ls_solutions/">3. Linked List Solutions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stack/">4. Stacks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../queues/">5. Queues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cldll/">6. Doubly Linked Lists and Circular Lists</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../">Data Structures & Algorithms</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../">Docs</a> &raquo;</li>
      
    <li>1. Introduction</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/intro.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="introduction">
<h1>1. Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h1>
<p>This book is a natural successor of my first book on C99 programming. Before
proceeding let me tell you that there are three books which you can read about
data structures and algorithm. The first and very deservingly so is the series
of books written by Donald Erwin Knuth. <a class="reference external" href="http://en.wikipedia.org/wiki/The_Art_of_Computer_Programming">The Art of Computer Programming</a>.
Please note that Knuth&#8217;s books is not for weak-hearted. :P
The next in the list is another excellent book <a class="reference external" href="http://www.amazon.com/Introduction-Algorithms-Thomas-H-Cormen/dp/0262033844">Introduction to Algorithms</a> by
Cormen, Leiserson, Rivest and Stein. Another very nice book in my opinion is
<a class="reference external" href="http://www.amazon.com/Handbook-Structures-Applications-Computer-Information/dp/1584884355">Handbook of Data Structures and Applications</a> edited by Dinesh P. Mehta.
Rest of the data structure books are more or less same and will fall in same
category.</p>
<p>Since I have written only my first book on C99 the examples will include only
knowledge from C99 book. As more languages are covered more examples will be
added with those languages.</p>
<p>What is it that makes Data Structures and Algorithms worth our time. Well, when
we write software we have to solve practical problems. And we solve certain
types of problems. For these problems we have certain solutions and we repeat
the solution for similar problems. This behavior leads to reuse of certain
types of data structure and algorithms. This also leads to a certain topic
known as Design Patterns. However, that is a subject of an entirely different
book.</p>
<p>Note that there are three different words in Data Strcutures and Algorithms.
Data itself is very important and we have to make sure it is what is most
important. Structure is important because that will make sure certain
algorithms can be applied in the way should be. Algorithms are important and
should be chosen according to data and structure. We really are not much
about what type data will have because we really cannot govern that. However,
we can choose structure and algorithm for that data. Note that structure and
algorithms should be appropriate for particular data in consideration.</p>
<p>There are specific structures which facilitate specific operations if they
are used to hold the data. For example, a stack allows to access data only
from top. A queue is helpful to realize a life-like queue. Binary trees are
helpful for faster searches. Graphs can be used for path-finding and and to
solve network problems. These are just few cases which I have cited. The area
of data structures and algorithms is immense and ever expanding.</p>
<p>Before we proceed let me tell you that you should refresh your Mathematics
because certain sections of this book will be involving, mathematically.
Particularly sections which will contain analysis of algorithms. One more
important point is that you should have pen and paper with you while trying
to study this book. Believe me it will help you a lot as I have experienced
it myself. Also, Knuth recommends that too. :-)</p>
<p>I expect that you have learned GDB and Valgrind from as suggested in my last
book. Be ready for some debugging in case programs give you trouble.</p>
<p>The way the book will present the concepts is that we will take up data
structures and algorithms. I will draw diagrams and apply algrithms on those
algorithms on those diagrams because you know a picture is worth thousand
words. :-) The language used to describe the data structures and algorithms
will be C99. Perhaps later more examples in different languages will be given.
Algorithms will be first described using pseudo code then real code.</p>
<div class="section" id="problem-to-solution">
<h2>1.1. Problem to Solution<a class="headerlink" href="#problem-to-solution" title="Permalink to this headline">¶</a></h2>
<p>Usually while programming you will face the situation when you have to write a
program to solve a problem. You will end up using few data structures and a
few algorithms to solve that program. This book describes the most common
data strutures and algorithms which have evolved over several centuries of
mathematical work by mathematicians. Given a problem we build a model of
solution (read program) in our mind. The details of that mental model varies
from individual to individual. Once that mental model is built our brains
orientation is fixed to a certain way of thinking. Now because of this we
choose certain data structures and algorithms and try to find out solution
using data starutures and algorithms chosen. Sometimes we are successful other
times we fail may be partially maybe fully. Now the most important thing when
we fail is to think over the problem again and get a fresh thinking. So better
take a break. This is most serious advice I can give. Whenever you have
difficulty solving a problem for more than 30 minutes take a break. This will
reset your thinking and allow you to think in new way and you can try to find
the solution afresh.</p>
</div>
<div class="section" id="preliminaries">
<h2>1.2. Preliminaries<a class="headerlink" href="#preliminaries" title="Permalink to this headline">¶</a></h2>
<p>First a bit of history. The word algorithm comes from the name of the 9th
century Persian Muslim mathematician Abu Abdullah Muhammad ibn Musa
Al-Khwarizmi. The word algorism originally referred only to the rules of
performing arithmetic using Hindu-Arabic numerals but evolved via European
Latin translation of Al-Khwarizmi&#8217;s name into algorithm by the 18th century.
The use of the word evolved to include all definite procedures for solving
problems or performing tasks. The question is a what is an algorithm.
Knuth&#8217;s first volume of The Art of Computer Programming gives a very detailed
definition. What I will say is that an algorithm is a finite seuquence of
well-defined operations on some input data which produces an ouput in finite
amount of time. Let us consider the classic Euclid&#8217;s algorthim for finding
greatest common divisor for two numbers. This algorthm has been described
by Euclid in his book <em>Elements</em> (book vii, propositions i and ii). Given
two numbers say <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">b</span></code> following steps need to be executed
for finding remainder. Please see how I am going to describe the algorithm.</p>
<p><strong>Algorithm A</strong> (<em>Euclid&#8217;s algorithm</em>). Given two positive integers <code class="docutils literal"><span class="pre">a</span></code>
and <code class="docutils literal"><span class="pre">b</span></code> find the greatest common divisor, i.e. the largest positive
integer which evenly divides (remainder after division is 0) both <code class="docutils literal"><span class="pre">a</span></code>
and <code class="docutils literal"><span class="pre">b</span></code>.</p>
<p><strong>A1.</strong> [Find remainder.] Divide <code class="docutils literal"><span class="pre">a</span></code> by <code class="docutils literal"><span class="pre">b</span></code>. Say <code class="docutils literal"><span class="pre">r</span></code> is remainder
(<code class="docutils literal"><span class="pre">r</span></code> will certainly be <span class="math">\(0\le r&lt;b\)</span>.).</p>
<p><strong>A2.</strong> [Is it zero?] If <code class="docutils literal"><span class="pre">r</span> <span class="pre">=</span> <span class="pre">0</span></code> terminate execution <code class="docutils literal"><span class="pre">b</span></code> is the GCD.</p>
<p><strong>A3.</strong> [Exchange values.] Set <code class="docutils literal"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">b</span></code> and <code class="docutils literal"><span class="pre">b</span> <span class="pre">=</span> <span class="pre">r</span></code>. Goto step A1.</p>
<p>I will use the word A for alorithm. This algorithm will have a monotonically
increasing suffix which will be a positive integer. When these algorithms
are later referenced a hyperlink will be made to refernce back to the
algorithm.</p>
<p>Some algorithms will have flowcharts given for them. For example, given
below is the flowchart for Euclid&#8217;s algorithm.</p>
<div class="figure">
<p><img src="../_images/tikz-9a4ec05d8fe414afe1f267434f8584629638f594.png" alt="\node at (0, 0) [rectangle, draw] (A1) {A1. Find remainder.};
\node at (5, 0) [rectangle, rounded corners=8pt, draw] (A2) {A2. Is reminder zero?};
\node at (10, 0) [rectangle, draw] (A3) {A3. Exchange value.};

\draw[-latex] (A1.east) -- (A2.west);
\draw[-latex] (A2.east) -- (A3.west);
\draw[-latex] (A2.south) -- ++(0, -1);
\draw[-latex] (A3.north) -- ++(0, .5) -| (A1.north);" /></p>
<p class="caption">Euclid's algorithm as a flowchart.</p></div><p>Let us see a C99 program which evaluates GCD of two numbers. Given below is
the sample code.</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Enter two positive integers separated by space:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d %d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>

  <span class="k">while</span><span class="p">(</span><span class="n">r</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">else</span> <span class="p">{</span>
      <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
      <span class="n">b</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;GCD is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that terminating condition for our program is that remainder becomes
zero. Typically we initialize variables with value 0 in C99 but in this case
it must be non-zero. Now let us look at some desirable properties of an
algorithm.</p>
</div>
<div class="section" id="efficiency">
<h2>1.3. Efficiency<a class="headerlink" href="#efficiency" title="Permalink to this headline">¶</a></h2>
<p>There can be several algorithms to achieve the same effect on a particular set
of data. However, the two methods may have different requirements on time
constraint. One may take more or less or equal time than the second one. We
definitely always want an algorithm which consumes less time. Time may not be
only contraint all the time. Sometimes we may be bound by amount of memory
available to use. This may forbade us from using those algorithms which consume
more memory even though they run faster. So there are two types of complexities
which are in question time and space.</p>
<p>There are two ways to measure time complexity. One is called big-O notation and
another is called amortized complexity. These notations are typically wrtten
as <span class="math">\(O(n), \Omega(n)\)</span> and <span class="math">\(\Theta(n)\)</span>. The symbol:math:<cite>O</cite> was first
introduced by number theorist Paul Bachmann in 1894, in the second volume of
his book Analytische Zahlentheorie (&#8220;analytic number theory&#8221;). The number
theorist Edmund Landau adopted it, and was thus inspired to introduce in 1909
the notation <span class="math">\(o\)</span>; hence both are now called Landau symbols. The big
<span class="math">\(O\)</span> was popularized in computer science by Donald Knuth, who
re-introduced the related Omega and Theta notations.Knuth also noted that the
Omega notation had been introduced by Hardy and Littlewood under a different
meaning &#8220;<span class="math">\(\ne o\)</span>&#8221; (i.e. &#8220;is not an <span class="math">\(o\)</span> of&#8221;).</p>
<p>There are three types of complexities of an algorithm. Best
case, average case and worst case. In <span class="math">\(O(n)\)</span> notation worst case
performance of an algorithm is considered. However, an amortized complexity does
not work like that. In an algorithm an operation may be costly but then its
frequency may be less. Amortized complexity takes care of this fact and tries to
balance the complexity value. Therefore big-O notation is useful when worst case
performance is entirely unacceptable otherwise amortized complexity can be used.</p>
<p>Now let us try to understand what is big-O notation and how to compute it.
Consider two functions <span class="math">\(f(x)\)</span> and <span class="math">\(g(x)\)</span>. Let us assume that these
functions operate on a subset of real numbers. Then in big-O notation
<span class="math">\(f(x)\)</span> is written in terms of <span class="math">\(g(x)\)</span> as follows:</p>
<div class="math">
\[f(x) = O(g(x))~as~x~\rightarrow~\infty\]</div>
<p>if and only if there is a positive constant <span class="math">\(K\)</span> such that for all
sufficiently large values of <span class="math">\(x,~f(x)\)</span> is at most K multiplied by
<span class="math">\(g(x)\)</span> in absolute value. That is, <span class="math">\(f(x)~=~O(g(x))\)</span> if and only if
there exists a positive real number <span class="math">\(K\)</span> and a real number <span class="math">\(x_0\)</span> such
that</p>
<div class="math">
\[\begin{split}|f(x)|~\le~K|g(x)|~for~all~x&gt;x_0\end{split}\]</div>
<p>We typically do not say that we are concerned with growth rate as <span class="math">\(x\)</span>
goes to <span class="math">\(\infty\)</span> and we simply write <span class="math">\(f(x) = O(g(x))\)</span>.The notation
can also be used to describe the behavior of <span class="math">\(f\)</span> near some real number
<span class="math">\(a\)</span> (often, <span class="math">\(a = 0\)</span>): we say</p>
<div class="math">
\[f(x) = O(g(x))~as~x~\rightarrow~a\]</div>
<p>if and only if there exist positive numbers <span class="math">\(\delta\)</span> and <span class="math">\(K\)</span> such that</p>
<div class="math">
\[\begin{split}|f(x)|~\le~K|g(x)|~for~|x-a|&lt;\delta\end{split}\]</div>
<p>If <span class="math">\(g(x)\)</span> is non-zero for values of <span class="math">\(x\)</span> sufficiently close to
<span class="math">\(a\)</span>, both of these definitions can be unified using the limit superior:</p>
<div class="math">
\[f(x) = O(g(x))~as~x \rightarrow a\]</div>
<p>if and only if</p>
<div class="math">
\[\begin{split}\lim\limits_{x\rightarrow a}\left\lvert\frac{f(x)}{g(x)}\right\rvert &lt; \infty\end{split}\]</div>
<p>To explain how we compute <span class="math">\(O(n)\)</span> let us see an example. Consider a polynomial
function with all positive coefficients. Say our polynomials is somthing like
<span class="math">\(f(x) = a_0x^n + a_1x^{n-1} + a_2x^{n-2} + ... + a_{n-1}x + a_n\)</span>. We can
very safely say</p>
<div class="math">
\[|f(x)| \le (a_0 + a_1 + ... + a_{n-1} + a_n)x^n~for~x\ge 1\]</div>
<p>Therefore we can say <span class="math">\(f(x) = O(x^n)\)</span>.</p>
<p>Given below is a plot of some most common functions encountered in algorithms.</p>
<a class="reference internal image-reference" href="../_images/functions_plot.png"><img alt="&quot;Time complexity of different functions.&quot;" class="align-center" src="../_images/functions_plot.png" /></a>
<p>Note that plot of <code class="docutils literal"><span class="pre">log(x)</span></code> is barely visible in output. As you can clearly
see <span class="math">\(log(x)&lt;x&lt;x*log(x)&lt;x^2&lt;x^3&lt;2^n\)</span>.</p>
<p>As <span class="math">\(O\)</span> -notation gives upper bound similarly <span class="math">\(\Omega\)</span> -notation
gives lower bound.</p>
<p><span class="math">\(g(n) = \Omega(f(n))\)</span> means there exists two constants <span class="math">\(L\)</span> and
<span class="math">\(n_0\)</span> such that</p>
<p><span class="math">\(g(n) \ge L|f(n)|\)</span> for all <span class="math">\(n&gt; n_0\)</span>.</p>
<p>If we want to write exact order of growth without being accurate about constant
factors <span class="math">\(L\)</span> and <span class="math">\(K\)</span> then we use <span class="math">\(\Theta\)</span> -notation.</p>
<p><span class="math">\(g(n) = \Theta(f(n)) \Leftrightarrow g(n) = O(f(n))\)</span> and <span class="math">\(g(n) =
\Omega(f(n))\)</span> implying <span class="math">\(\Theta\)</span> -notation gives both upper and lower
bounds.</p>
<p>In computer science for algorithm analysis we are almost always worried about
big-<span class="math">\(O\)</span> complexity because it gives upper bound i.e. for large set of
input how the algorithm will behave.</p>
<p>Continuing this let us discuss a bit more about
big-<span class="math">\(O\)</span> notation. The problem with big-<span class="math">\(O\)</span> notation is that even
though it talks about two contants <span class="math">\(x_0\)</span> and <span class="math">\(K\)</span> it does not give
any hints about there values or how to compute them. It also does not put any
restriction on the values of these constants not gives any guidelines when
there are many such values.</p>
<p>There is also space efficiency or memory efficiency. There are times when the
devices we use do not have a lot of memory then we need to find algorithms
which are efficient memory-wise. For example, there are two very good
algorithms for sorting an array of values (or string) quick sort and merge
sort. However, consider the case when we have less memory than the array
then neither of these algorithms can be used. One of the sorting algorithms
among many is external sort. This technique is old because in earlier devices
memory was less and usually data to be sorted was more.</p>
</div>
<div class="section" id="examples-of-asymptotic-complexity-computation">
<h2>1.4. Examples of Asymptotic Complexity Computation<a class="headerlink" href="#examples-of-asymptotic-complexity-computation" title="Permalink to this headline">¶</a></h2>
<p>In an algorithm analysis we have to consider all operations although many times
if the code is simple you can just see and guess the complexity. However, in
case of complex code you will find it difficult to do that. For example
consider the following code which computes sum of <code class="docutils literal"><span class="pre">n</span></code> numbers stored in an
array.</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">sum</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
  <span class="n">sum</span> <span class="o">+=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</pre></div>
</div>
<p>First we have two initializations for <code class="docutils literal"><span class="pre">i</span></code> and <code class="docutils literal"><span class="pre">sum</span></code>. Let cost of assignment
be <span class="math">\(C_1\)</span>. Then <code class="docutils literal"><span class="pre">i</span></code> is incremented from <code class="docutils literal"><span class="pre">0</span></code> to <code class="docutils literal"><span class="pre">n-1</span></code>. Let cost of
increment be <span class="math">\(C_2\)</span>. Now There are <code class="docutils literal"><span class="pre">n</span></code> additions and <code class="docutils literal"><span class="pre">n</span></code> assignments
for <code class="docutils literal"><span class="pre">sum</span></code>. Let cost of addition is <span class="math">\(C_3\)</span>. So total cost is
<span class="math">\(n*(C_1 + C_3)\)</span>. Thus total cost is <span class="math">\(2*C_1 + n*C_2 + n*(C_1 + C+3)\)</span>
i.e. <span class="math">\((2+n)C_1 + n*C_2 + n*C_3\)</span>. These constants <span class="math">\(C_1, C_2\)</span> and
<span class="math">\(C_3\)</span> can be measured in terms of clock cycles. Thus complexity is
<span class="math">\(O(n)\)</span>.</p>
<p>As you can guess if we have nested loops complexity wil increase in terms of
power of <span class="math">\(n\)</span>. However, the complexity may not increase exactly by
integral power.</p>
</div>
<div class="section" id="simplicity">
<h2>1.5. Simplicity<a class="headerlink" href="#simplicity" title="Permalink to this headline">¶</a></h2>
<p>It is not enough for an algorithm to be efrficient from the perspective of
memory and time but it should also be simple enough to implement. For example,
splay-trees are very good for maintaining fast search time. But the
implementation is complex compared to a Red-Black tree or AVL-tree therefore
they are usually not preferred. However, this is not the only reason. I will
let you know more detail when we discuss trees in their own chapter.</p>
</div>
<div class="section" id="problems-on-complexity">
<h2>1.6. Problems on Complexity<a class="headerlink" href="#problems-on-complexity" title="Permalink to this headline">¶</a></h2>
<p>For each of the following pairs of functions <span class="math">\(f(n)\)</span> and <span class="math">\(g(n)\)</span>,
either <span class="math">\(f(n) = O(g(n))\)</span> or <span class="math">\(g(n) = O(f(n))\)</span>, but not
both. Determine the case.</p>
<ol class="arabic simple">
<li><span class="math">\(f(n) = (n^2 - n)/2, g(n) = 6n\)</span>.</li>
<li><span class="math">\(f(n) = n + 2\sqrt{n}, g(n) = n^2\)</span>.</li>
<li><span class="math">\(f(n) = n + \log n, g(n) = n\sqrt{n}\)</span>.</li>
<li><span class="math">\(f(n) = n\log n, g(n) = n\sqrt{n}/2\)</span>.</li>
<li><span class="math">\(f(n) = n + \log n, g(n) = \sqrt{n}\)</span>.</li>
<li><span class="math">\(f(n) = 2(\log n)^2 , g(n) = \log n + 1\)</span>.</li>
<li><span class="math">\(f(n) = 2(\log n)^2 , g(n) = \log n + 1\)</span>.</li>
<li><span class="math">\(f (n) = 4n \log n + n, g(n) = (n^2 - n)/2\)</span>.</li>
</ol>
<p>Which of the following cases are true and which are false?</p>
<ol class="arabic simple" start="9">
<li><span class="math">\(n^2 = O(n^3)\)</span>.</li>
<li><span class="math">\(n^3 = O(n^2)\)</span>.</li>
<li><span class="math">\(n\log n = O(n\sqrt{n})\)</span>.</li>
<li><span class="math">\(\sqrt{n} = O(\log n)\)</span>.</li>
<li><span class="math">\(\log n = O(\sqrt{n})\)</span>.</li>
<li><span class="math">\(n^3 = O(n^2(1 + n^2))\)</span>.</li>
<li><span class="math">\(1/n = O(\log n)\)</span>.</li>
<li><span class="math">\(\log n = O(1/n)\)</span>.</li>
<li><span class="math">\(\log n = O(n^{-1/2})\)</span>.</li>
<li>If <span class="math">\(f(n) \sim g(n)\)</span>, then <span class="math">\(f(n) = \Theta(g(n))\)</span>.</li>
<li>If <span class="math">\(f(n) = \Theta(g(n))\)</span>, then <span class="math">\(g(n) = \Theta(f(n))\)</span>.</li>
</ol>
<p>Give proof for following:</p>
<ol class="arabic" start="20">
<li><p class="first">Does <span class="math">\(n^{\log n} = O((\log n)^n)\)</span>?</p>
</li>
<li><p class="first">Does <span class="math">\(n^{\log n} = \Omega((\log n)^n)\)</span>?</p>
</li>
<li><p class="first">Does <span class="math">\(n^{\log \log \log n} = O((\log n)!)\)</span>?</p>
</li>
<li><p class="first">Does <span class="math">\(n^{\log \log \log n} = \Omega((\log n)!)\)</span>?</p>
</li>
<li><p class="first">Does <span class="math">\((n!)! = O(((n - 1)!)!(n - 1)!^{n!})\)</span>?</p>
</li>
<li><p class="first">Does <span class="math">\((n!)! = \Omega(((n - 1)!)!(n - 1)!^{n!})\)</span>?</p>
</li>
<li><p class="first">Does</p>
<div class="math">
\[O\left(\left(\frac{n^2}{\log \log n}\right)^{1/2}\right) =
O(\lfloor\sqrt{n}\rfloor)\]</div>
</li>
<li><p class="first">Does <span class="math">\(2^{(1+O(1/n))} = 2 + O(1/n)\)</span>.</p>
</li>
<li><p class="first">Prove that if <span class="math">\(f_1(n) = O(g_1(n))\)</span> and <cite>f_2(n) = O(g_2(n))</cite>, then
<span class="math">\(f_1(n) + f_2(n) = O(g_1(n) + g_2(n))\)</span>.</p>
</li>
<li><p class="first">Prove that if <span class="math">\(f_1(n) = \Omega(g_1(n))\)</span> and <cite>f_2(n) =
Omega(g_2(n))</cite>, then <span class="math">\(f_1(n) + f_2(n) = O(g_1(n) + g_2(n))\)</span>.</p>
</li>
<li><p class="first">Prove that if <span class="math">\(f_1(n) = O(g_1(n))\)</span> and <cite>f_2(n) = O(g_2(n))</cite>, then
<span class="math">\(f_1(n) + f_2(n) = O(max\{g_1(n), g_2(n)\})\)</span>.</p>
</li>
<li><p class="first">Prove that if <span class="math">\(f_1(n) = \Omega(g_1(n))\)</span> and <cite>f_2(n) =
Omega(g_2(n))</cite>, then <span class="math">\(f_1(n) + f_2(n) = \Omega(min\{g_1(n),
g_2(n)\})\)</span>.</p>
</li>
<li><p class="first">Prove or disprove: For all functions <span class="math">\(f(n)\)</span> and <span class="math">\(g(n)\)</span>, either
<span class="math">\(f(n) = O(g(n))\)</span> or <span class="math">\(g(n) = O(f(n))\)</span>.</p>
</li>
<li><p class="first">Prove or disprove: If <span class="math">\(f(n) &gt; 0\)</span> and <span class="math">\(g(n) &gt; 0\)</span> for all
<span class="math">\(n\)</span>, then <span class="math">\(O(f(n) + g(n)) = f(n) + O(g(n))\)</span>.</p>
</li>
<li><p class="first">Prove or disprove: <span class="math">\(O(f(n)^{\alpha}) = O(f(n))^{\alpha}\)</span> for all
<span class="math">\(\alpha \in \mathbf{R^+}\)</span>.</p>
</li>
<li><p class="first">Prove or disprove: <span class="math">\(O(x + y)^2 = O(x^2) + O(y^2)\)</span>.</p>
</li>
</ol>
</div>
<div class="section" id="mathematical-induction">
<h2>1.7. Mathematical Induction<a class="headerlink" href="#mathematical-induction" title="Permalink to this headline">¶</a></h2>
<p>Mathematical induction is a powerful technique to prove certain mathematical
equalities and inequqlities. To analyze an algorithm we can use mathematical
induction. There will be many times when analyzing an algorithm mathematical
induction will come handy. Many of the readers may be familiar with it
and many may not. Therefore, I will start with basics of this
particular technique. We will then develop some basic formulas to be used in
this book. We use mathematical induction technique in following way.</p>
<p>Given a statement <span class="math">\(S(n)\)</span> we first prove <span class="math">\(S(1), S(2)\)</span> and
<span class="math">\(S(3)\)</span> are true. We then assume <span class="math">\(S(k)\)</span> is true. After that we prove
<span class="math">\(S(n+1)\)</span> to be true. After this we can draw conclusion that <span class="math">\(S(n)\)</span>
is true for all <span class="math">\(n\)</span>.</p>
<p>Consider a statement that</p>
<div class="math" id="equation-Sum of first n positive integers.">
<span class="eqno">(1)</span>\[\sum_{i=1}^{n}i = \frac{n*(n+1)}{2}\]</div>
<p>now if we have to prove this then we will perform following step:</p>
<p><strong>Algorithm A1</strong></p>
<p><strong>A1.1</strong> Prove for <span class="math">\(S(1)\)</span></p>
<p><strong>A1.2</strong> Prove for <span class="math">\(S(2)\)</span></p>
<p><strong>A1.3</strong> Assume <span class="math">\(S(k)\)</span> to be true.</p>
<p><strong>A1.4</strong> Prove <span class="math">\(S(k+1)\)</span> to be true.</p>
<p>Therefore for step <strong>A1.1</strong> <span class="math">\(S(1) = 1 = \frac{1*2}{2}\)</span>. So <span class="math">\(S(1)\)</span> is
true. For step <strong>A1.2</strong> <span class="math">\(S(2) = 1 + 2 = 3 = \frac{2*3}{2}\)</span>. Now
<span class="math">\(S(2)\)</span> is also true. Let us say</p>
<div class="math">
\[\sum_{i=0}^{k} = \frac{k*(K+1)}{2}\]</div>
<p>now <span class="math">\(S(k+1) = k*(k+1)/2 + k+1 = (K+1)*(k+1+1)/2\)</span>. Hence, by mathematical
induction we have proven the statement.</p>
<p>Therefore we can draw following flowchart for mathematical induction.</p>
<div class="figure">
<p><img src="../_images/tikz-a63d66708809160f5b5f8d9d9ee0f09a96fb5cb3.png" alt="\node at (0, 0) [rectangle, draw] (A1) {Prove S(1) to be true.};
\node at (0, -1.5) [rectangle, draw] (A2) {Prove S(2) to be true.};
\node at (0, -3) [rectangle, draw] (A3) {Prove S(k) to be true.};
\node at (0, -4.5) [rectangle, draw] (A4) {Prove S(k+1) to be true.};

\draw[-latex] (A1.south) -- (A2.north);
\draw[-latex] (A2.south) -- (A3.north);
\draw[-latex] (A3.south) -- (A4.north);" /></p>
<p class="caption">Flowchart for mathematical induction.</p></div><p>Let us consider another simple example which will further help boost our foundations
of mathematical induction.</p>
<p>Consider a statement saying</p>
<div class="math" id="equation-Sum of first n odd numbers">
<span class="eqno">(2)</span>\[S(n) = 1 + 3 + 5 + ... + (2n - 1) = n^2\]</div>
<p>Now we first find <span class="math">\(S(1) = 1 = 1^2\)</span> which is true. For <span class="math">\(n = 2\)</span> we
have <span class="math">\(S(n) = 1 + 3 = 4 = 2^2\)</span>. Now let us assume it is true for <span class="math">\(k\)</span>.
Now let us try for <span class="math">\(k+1\)</span>. <span class="math">\(S(k+1) = k^2 + 2k + 1  = (k+1)^2\)</span>.
Therefore, we have proven the series to be true for <span class="math">\(S(n)\)</span>.</p>
<p>You can visualize this using a geographical representation too. I would like to
ask the reader to find the visual diagram as an exercise.</p>
</div>
<div class="section" id="some-basic-mathematics">
<h2>1.8. Some Basic Mathematics<a class="headerlink" href="#some-basic-mathematics" title="Permalink to this headline">¶</a></h2>
<p>Let us see a way to find sum of first <span class="math">\(n\)</span> numbers. Typically we use symbol
<span class="math">\(\sum\)</span> to denote the sum. The following notations are used.</p>
<p><span class="math">\(\sum_{1\le i\le n}i\)</span>, <span class="math">\(\sum_{1\le i\le n}a_i\)</span> and <span class="math">\(\sum_{i=0}^na_i\)</span>
to denotes the sum of numbers
1 to <span class="math">\(n\)</span> and series <span class="math">\(a_1+a_2+a_3+...+a_n\)</span> respetively.</p>
<p>Let us try to find sum of first <span class="math">\(n\)</span> numebers using another method which
will not use mathematical induction.</p>
<div class="math" id="equation-Forward sum of first n positive integers.">
<span class="eqno">(3)</span>\[\sum_{1\le i\le n} = 1 + 2 + ... + n-1 + n\]</div>
<p>The same can be written by reversing the series in following manner</p>
<div class="math" id="equation-Reverse sum of first n positive integers.">
<span class="eqno">(4)</span>\[\sum_{1\le i\le n} = n + n-1 + ... + 3 + 2 + 1\]</div>
<p>Now if we sum the series we will get following</p>
<div class="math" id="equation-Sum of two series of first n positive integers.">
<span class="eqno">(5)</span>\[2*\sum_{1\le i\le n} = n-1 + n-1 + ... n~times = n*(n-1)\]</div>
<p>So now we can clearly get our result mentioned in the above section.</p>
<p>Before we proceed let us take a look at following solution:</p>
<div class="math">
\[\sum_{1\le i\le n} = \frac{n(n+1)(2n+1)}{6}\]\[\sum_{i=0}^{n}(i+1)^2 - i^2 = \sum_{i=0}^{n}=\sum_{i=0}^{n}(2i+1)\]\[= n(n+1) + n = n^2 + 2n\]\[\Rightarrow \sum_{i=0}^ni = \frac{n^2 +2n - n}{2}= \frac{n(n+1)}{2}\]</div>
<p>Now by the same analogy let us try to find out sum of squares.</p>
<div class="math">
\[\sum_{i=0}^{n}(i+1)^3 - i^3 = \sum_{i=0}^{n}(3i^2 + 3i +1) = (n+1)^3 - 1^3\]\[\Rightarrow \sum_{i=0}^ni^2 = \frac{n(n+1)(2n+1)}{6}\]</div>
<p>There is one more generic notation <span class="math">\(\sum_{R(i)}a_i\)</span>. Here, <span class="math">\(R(i)\)</span>
is any relation which involves <span class="math">\(i\)</span>. The notation here means sum of all
<span class="math">\(a_i\)</span> for <span class="math">\(i\)</span> for which relation <span class="math">\(R(i)\)</span> is true. Now let us
study some basic laws with this notation.</p>
<p>Distributive Law, for multiplication of such sums:</p>
<div class="math" id="equation-Product of two sums.">
<span class="eqno">(6)</span>\[\left (\sum_{R(i)}a_i\right)\left (\sum_{S(j)}b_j\right) = \sum_{R(i)}\left (\sum_{S(j)}a_ib_j\right)\]</div>
<p>For example consider the follwing case:</p>
<div class="math">
\[\begin{split}\left(\sum_{0&lt;i&lt;3}a_i\right) \left(\sum_{0&lt;j&lt;3}b_j\right) = (a_1+a_2)(b_1+b_2)\end{split}\]\[=(a_1b_1+a_1b_2) + (a_2b_2+a_2b_2)\]\[\begin{split}= \sum_{0&lt;i&lt;3} \left (\sum_{0&lt;j&lt;3}a_ib_j\right)\end{split}\]</div>
<p>Interchanging order of summation:</p>
<div class="math" id="equation-Interchanging order of summation.">
<span class="eqno">(7)</span>\[\sum_{R(i)}\sum_{S(j)}a_{ij} = \sum_{S(i)}\sum_{R(j)}a_{ij}\]</div>
<p>The reader is to prove this. This is left as an exercise.</p>
<p>Change of variable:</p>
<div class="math" id="equation-Change of variable.">
<span class="eqno">(8)</span>\[\sum_{R(i)}a_i = \sum_{R(j)}a_j = \sum_{R(p(j))}a_{p(j)}\]\[\text{We can consequently write}\]\[\begin{split}\sum_{0&lt;i&lt;n}a_i = \sum_{0&lt;i-1&lt;n}a_{i-1} = \sum_{c&lt;j&lt;n+c}a_{j-c} = \sum_{-c&lt;j&lt;n-c}a_{j+c}\end{split}\]</div>
<p>Hacking the relation:</p>
<div class="math" id="equation-Hacking the relation.">
<span class="eqno">(9)</span>\[\sum_{R(i)}a_i + \sum_{S{i}}a_i = \sum_{R(i)~orS(i)}a_i+\sum_{R(i)~and~S(i)}a_i\]</div>
<p>Given these four rules reader is encouraged to find the sum an arithmetic and
an geometric progression.</p>
<p>I think I should stop here now and ask the reader to brush up his math skills.
These derivations are just a glimpse of what you will need to analyze the
algorithms.</p>
</div>
<div class="section" id="algorithms-and-adt-implementation">
<h2>1.9. Algorithms and ADT Implementation<a class="headerlink" href="#algorithms-and-adt-implementation" title="Permalink to this headline">¶</a></h2>
<p>An ADT is a generalized form of data type not necesssarily integers or real
numbers. For example, a set of boolean values used to represent arbitrary
binary or ternary numbers are abstract data types. An abstract data types
can be implemented by compound types of programming languages such as
structures in C or classes in C++ or such object-oriented languages.
A more succinct (and <em>mathematically close</em>) definition would be that we can
think of ADTs as mathematical model with a collection of operations defined
on that ADT. When we define ADT as a mathematical model, we are not concerned
with time or space efficiency. Time or space complexity are problems of
implementation not modelling. It is quite possible that a certain ADT cannot be
implemented on certain hardware or software. But by specifying the mathematical
and logical attributes of a data type or structure or class, the ADT serves as
a good starting guideline to programmers at least.</p>
<p>Different books choose different ways to formulate ADT but in this book I will
focus on implementation using C programming language. Thus we will be dealing
with more code than abstract concept.</p>
<p>Usually algorithms take form of functions and abstract data types take form
of classes and structs when written as a program. The reason for this is
ADTs can usually be represented as nouns while algorithms can be represented
by verbs. Remember algorithm operate on ADTs. Both this type of conversion
helps us in generalization and encapsulation. I will not go into details as to
how this conversion achieves this generalization and encapsulation because
that is out of scope of this book.</p>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../ls/" class="btn btn-neutral float-right" title="2. Linear Structures" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../" class="btn btn-neutral" title="Data structures and Algorithms Contents" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2012, Shiv S. Dayal.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>