

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-17487464-6']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>4. Operators and Expressions &mdash; C Programming  documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="C Programming  documentation" href="../"/>
        <link rel="next" title="5. Control Flow" href="../cf/"/>
        <link rel="prev" title="3. Console I/O" href="../io/"/>
<link rel="stylesheet" href="../../css/math.css" type="text/css" />


  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../" class="icon icon-home"> C Programming
          

          
          </a>

          
            
            
              <div class="version">
                0.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search/" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../introduction/">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../basics/">2. Basics of C</a></li>
<li class="toctree-l1"><a class="reference internal" href="../io/">3. Console I/O</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">4. Operators and Expressions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#scope-of-an-identifier">4.1. Scope of an Identifier</a></li>
<li class="toctree-l2"><a class="reference internal" href="#linkages-of-an-identifier">4.2. Linkages of an Identifier</a></li>
<li class="toctree-l2"><a class="reference internal" href="#storage-duration-of-objects">4.3. Storage Duration of Objects</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#usual-arithmetic-conversions">4.3.1. Usual Arithmetic Conversions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#expressions">4.3.2. Expressions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#primary-expressions">4.3.2.1. Primary Expressions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#operators">4.3.3. Operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="#additive-operators">4.3.4. Additive Operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="#multiplicative-operators">4.3.5. Multiplicative Operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="#relational-operators">4.3.6. Relational Operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="#equality-operators">4.3.7. Equality Operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="#increment-and-decrement-operators">4.3.8. Increment and Decrement Operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="#logical-operators">4.3.9. Logical Operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bitwise-operators">4.3.10. Bitwise Operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bitwise-shift-operators">4.3.11. Bitwise Shift Operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="#assignment-operators">4.3.12. Assignment Operators</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#simple-assignment">4.3.12.1. Simple Assignment</a></li>
<li class="toctree-l4"><a class="reference internal" href="#compound-assignment">4.3.12.2. Compound Assignment</a></li>
<li class="toctree-l4"><a class="reference internal" href="#conditoinal-operators">4.3.12.3. Conditoinal Operators</a></li>
<li class="toctree-l4"><a class="reference internal" href="#comma-operators">4.3.12.4. Comma Operators</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sizeof-operators">4.3.12.5. sizeof Operators</a></li>
<li class="toctree-l4"><a class="reference internal" href="#unary-arithmetic-operators">4.3.12.6. Unary Arithmetic Operators</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#grouping-parentheses">4.3.13. Grouping parentheses</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../cf/">5. Control Flow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ap/">6. Arrays and Pointers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../func/">7. Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../su/">8. Structures and Unions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../strings/">9. Strings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fileio/">10. File Input/Output</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fs/">11. Following Specification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../env/">12. Environment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lang/">13. Language</a></li>
<li class="toctree-l1"><a class="reference internal" href="../macros/">14. Preprocessing Directives</a></li>
<li class="toctree-l1"><a class="reference internal" href="../std/">15. The C Standard Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../assert/">16. Diagnostics <code class="docutils literal"><span class="pre">&lt;assert.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../complex/">17. Complex arithmetic <code class="docutils literal"><span class="pre">&lt;complex.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../ctypes/">18. Character Handling <code class="docutils literal"><span class="pre">&lt;ctype.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../errno/">19. Errors <code class="docutils literal"><span class="pre">&lt;errno.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../fenv/">20. Floating-point environment <code class="docutils literal"><span class="pre">&lt;fenv.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../float/">21. Characteristics of floating types <code class="docutils literal"><span class="pre">&lt;float.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../inttypes/">22. Format conversion of integer types <code class="docutils literal"><span class="pre">&lt;inttypes.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../iso646/">23. Alternative spellings <code class="docutils literal"><span class="pre">&lt;iso646.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../limits/">24. Sizes of integer types <code class="docutils literal"><span class="pre">&lt;limits.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../locale/">25. Localization &lt;locale.h&gt;</a></li>
<li class="toctree-l1"><a class="reference internal" href="../math/">26. Mathematics <code class="docutils literal"><span class="pre">&lt;math.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../setjmp/">27. Nonlocal jumps <code class="docutils literal"><span class="pre">&lt;setjmp.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../signal/">28. Signal handling <code class="docutils literal"><span class="pre">&lt;signal.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../stdarg/">29. Variable arguments <code class="docutils literal"><span class="pre">&lt;stdarg.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../stdbool/">30. Boolean type and values <code class="docutils literal"><span class="pre">&lt;stdbool.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../stddef/">31. Common definitions <code class="docutils literal"><span class="pre">&lt;stddef.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../stdint/">32. Integer types <code class="docutils literal"><span class="pre">&lt;stdint.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../stdio/">33. Input/output <code class="docutils literal"><span class="pre">&lt;stdio.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../stdlib/">34. General utilities <code class="docutils literal"><span class="pre">&lt;stdlib.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../string/">35. String handling <code class="docutils literal"><span class="pre">&lt;string.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../tgmath/">36. Type-generic math <code class="docutils literal"><span class="pre">&lt;tgmath.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../time/">37. Date and time <code class="docutils literal"><span class="pre">&lt;time.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../wchar/">38. Extended multibyte and wide character utilities <code class="docutils literal"><span class="pre">&lt;wchar.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../wtype/">39. Wide character classification and mapping utilities <code class="docutils literal"><span class="pre">&lt;wctype.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../problems/">40. Problems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../license/">41. License</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../">C Programming</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../">Docs</a> &raquo;</li>
      
    <li>4. Operators and Expressions</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/oae.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="operators-and-expressions">
<h1>4. Operators and Expressions<a class="headerlink" href="#operators-and-expressions" title="Permalink to this headline">¶</a></h1>
<p>Operators and expressions are in the core of every programming language. They
form the major part of BNF grammar. They also decide how the syntax will look
like. You as a programmer will spend considerable time using C operators. C has
sevral type of operators like arithmetic operators, relational operators,
bitwise operators, unary operators, logical operators to name some of them.
Since C was first of very poopular structured general-pupose lnguages therefore
many modern language use almost all the operators and supplement with their own.
It is needless to say that to become a good programmar you must know all the
operators of C and know where to use which one as it may decide performance,
readability, simplicity of your code. Whenever you see array and pointer in
following sections just plow through them. All will be clear soon.</p>
<p>Before we can proceed to discuss operators and expressions I will explain
scope, linkage and storage durations which can be applied to
variables. These are given in specification starting in
<span class="math">\(\S(\text{iso.6.2.1})\)</span> and ending at <span class="math">\(\S(\text{iso.6.2.4})\)</span>.</p>
<div class="section" id="scope-of-an-identifier">
<h2>4.1. Scope of an Identifier<a class="headerlink" href="#scope-of-an-identifier" title="Permalink to this headline">¶</a></h2>
<p>Till now we have seen plain variables and their identifiers. However, there are
other identifiers as well which will be discussed later. For now we will
consider scope of plain variables. In general there are three kinds of
scope. Global scope, function scope and block scope. Variables declared outside
any function have global scope and they persist throughout the lifetime of the
program. Variables declared inside functions at outermost level have function
scope and they live as long as function remains active. A block in C is marked
by braces({ and }). Function bodies are also marked by this. Here I mean
blocks inside a function. Starting from C99 you can declare variables anywhere
inside a function and this block variables which have less lifetime than
functions are possible. We will see more of these when we see more code. Note
that identifiers can be reused in different scopes. For example, a loop index
integer identifier is repeated many times but every time it is a new
variable(We will see loops soon). Two identifiers have same scope if and only
if their scope terminates at the same point.</p>
</div>
<div class="section" id="linkages-of-an-identifier">
<h2>4.2. Linkages of an Identifier<a class="headerlink" href="#linkages-of-an-identifier" title="Permalink to this headline">¶</a></h2>
<p>There are three different kinds of linkages. External, internal and
none. Global variables and functions have external linkage as long as they are
not static. If they are static then they have internal linkage. By external
linkage we mean that for a program which consists of multiple source code files
these functions and variable identifiers can be referred in files other than in
which they are declared. When functions and global variables are static
i.e. they have internal linkage they cannot be accessed in other source code
files.</p>
<p>The following identifiers have no linkage: an identifier declared to be
anything other than an variable or a function; an identifier declared to be a
function parameter; a block scope identifier for an object declared without the
storage-class specifier <code class="docutils literal"><span class="pre">extern</span></code>.</p>
</div>
<div class="section" id="storage-duration-of-objects">
<h2>4.3. Storage Duration of Objects<a class="headerlink" href="#storage-duration-of-objects" title="Permalink to this headline">¶</a></h2>
<p>There are four storage durations. Static, thread, automatic and
allocated. Here, we will not discuss thread which we will talk about later. A
static variable which is local to a function of global variable has static
duration and it lives in data segment in memory and has static storage
duration. A variable local to a function or block which is not dynamically
allocated on heap by using either of <code class="docutils literal"><span class="pre">malloc,</span> <span class="pre">calloc</span></code> or <code class="docutils literal"><span class="pre">realloc</span></code> has
automatic storage and has function or block has automatic storage and is
cleaned up automatically and it lives on stack. Allocated storage duration
variables can persist as long as they want after allocation on heap by using
one of <code class="docutils literal"><span class="pre">malloc,</span> <span class="pre">calloc</span></code> and <code class="docutils literal"><span class="pre">realloc</span></code> as long as the name is kept
in scope and a corresponding <code class="docutils literal"><span class="pre">free</span></code> is not called on that name of the
variable. Now let us discuss operators and expressions.</p>
<p>Whenever operators and expressions come in picture you may have a set of mixed
data then to perform oration data is converted from one type to another. This
has an entire section devoted to it in specification at
<span class="math">\(\S(\text{iso.6.3})\)</span>. There are two
types of conversions. Many operators convert their operands silently which is
called &#8220;implicit conversion&#8221; and then we have cast operators
which we can use to explicitly convert values from one type to another which is
called &#8220;explicit conversion&#8221;. We will first see implicit conversion.</p>
<div class="section" id="usual-arithmetic-conversions">
<span id="index-0"></span><h3>4.3.1. Usual Arithmetic Conversions<a class="headerlink" href="#usual-arithmetic-conversions" title="Permalink to this headline">¶</a></h3>
<p>Many operators that expect operands of arithmetic type cause conversions and
yield result types in a similar way. The purpose is to determine a common real
type for the operands and result. For the specified operands, each operand is
converted, without change of type domain, to a type whose corresponding real
type is the common real type. Unless explicitly stated otherwise, the common
real type is alo the corresponding real type of the result, whose type domain is
the type domian of the operands if they are the same, and complex otherwise.
This pattern is called the usual <em>arithmetic convresions</em>:</p>
<ul class="simple">
<li>First, if the corresponding real type of either operand is <code class="docutils literal"><span class="pre">long</span> <span class="pre">double</span></code>,
the other operand is converted, without change of type domain, to a type
whose coresponding real type is <code class="docutils literal"><span class="pre">long</span> <span class="pre">double</span></code>.</li>
<li>Otherwise, if the corresponding real type of either operand is <code class="docutils literal"><span class="pre">double</span></code>, the
other operand is converted, without change of type domain, to a type whose
coreesponding real type is <code class="docutils literal"><span class="pre">double</span></code>.</li>
<li>Otherwise, if the corresponding real type of either operand is <code class="docutils literal"><span class="pre">float</span></code>, the
other operand is converted, without change of type domain, to a type whose
coreesponding real type is <code class="docutils literal"><span class="pre">float</span></code>.</li>
<li>Otherwise, the integer promotions are performed on both operands. Then the
following rules are applied to the promoted operands:<ul>
<li>If both operands have the same type, then no further conversion is needed.</li>
<li>Otherwise, if both operands have signed integer types or both have unsigned
integer types, the operand with the type of lesser integer conversion rank
is converted to the type of the operand with greater rank.</li>
<li>Otherwise, if the operand that has unsigned integer type has rank greater
or equal to the rank of the type of the other operand, then the operand with
signed integer type is converted to the type of the operand with unsigned
integer type.</li>
<li>Otherwise, if the type of the operand with signed integer type can represent
all of the values of the type of the operand with unsigned integer type,
then the operand with unsigned integer type is converted to the type of the
operand with signed integer type.</li>
<li>Otherwise, both operands are converted to the unsigned integer type
corresponding to the type of the operand with signed integer type.</li>
</ul>
</li>
<li>The values of floating operands and of the results of floating expressions may
be represented in greater precision and range than that required by the type;
the types are not changed thereby.</li>
</ul>
</div>
<div class="section" id="expressions">
<span id="index-1"></span><h3>4.3.2. Expressions<a class="headerlink" href="#expressions" title="Permalink to this headline">¶</a></h3>
<p>Majority of this comes from specification n1570.pdf. An expression is a
sequence of operators and operands. This sequence of operators and operands will
lead to some computation; needless to say, however, it may designate an object
or a function or it may generate a side effect or a combination. The value
computations of the operands of an operator are sequenced before the value
computation of the result of the operator.</p>
<p>Consider the following where <code class="docutils literal"><span class="pre">++</span></code> is used as prefix and postfix increment
unary operator, which should increment the value of operand after evaluating the
operand:</p>
<div class="highlight-text"><div class="highlight"><pre>i = ++i + 1;

a[i++] = i;
</pre></div>
</div>
<p>however, this is an undefined bahavior because if a side effect on a scalar
(all arithmetic and pointer types are scalar) object is unsequenced relative to
either a different side effect on the same scalar onject or a value computation
using the value of the same scalar object,  the behavior is undefined. If there
are multiple allowable orderings of the subexpression of an expression, the
behavior is undefined if such an unsequenced side effect occurs in any of the
orderings.</p>
<p>The groupings of operators and operands is indicated by the syntax. The syntax
specifies the precedence of operators in the evaluation, highest precedence
first. The table is given later. The exceptions are cast expressions as operands
of unary operators, and an operand contained between any of the following pairs
of operators: grouping parentheses (), subscripting brackets[], function call
parentheses (), and the conditional operator ?:. Except as specified later,
side effects and value computations of subexpressions are unsequenced. In an
expression that is evaluated more than once during the execution of a program,
unsequenced and indeterminately sequenced evaluations of its subexpressions
need not be performed consistently in different evaluations.</p>
<p>Some operators (the unary operator ~, and the binary operators &lt;&lt;, &gt;&gt;, &amp;, ^,
and |, collectively described as bitwise opearators) are required to have
operands that have integer types. These operators yield values that depend on
the internal representation of intergers, and have implementation-defined and
undefined aspects for signed types.</p>
<p>If an exceptional condition occurs during the evaluation of an expression (that
is, if the result is not mathematicslly defined or not in the range of
representable values for its type), the behavior is undefined.</p>
<p>The effective type of an object for an access to its stored value is the
declared type of the object, if any. Note that allocated objects have no
declared type. If a value is stored into an object having no declared type
through an lvalue (a value whose address can be taken) having a type that is not
a character type, then the type of the lvalue becomes the effective type of the
object for that access and for subsequent accesses that do not modify the stored
value. If a value is copied into an object having no declared type using
<code class="docutils literal"><span class="pre">memcpy</span></code> or <code class="docutils literal"><span class="pre">memmove</span></code>, or is copied as an array of character type, then the
effective type of the modified object for that access and for subsequent
accesses that do not modify the value is the effective type of the object from
which the value is copied, if it has one. For all other accesses to an object
having no declared type, the effective type of the object is simply the type of
the lvalue used for the access.</p>
<p>An object will have its stored value accessed only by an lvalue expression that
has one of the following types:</p>
<ul class="simple">
<li>a type compatible with the effective type of the object,</li>
<li>a qualified version of a type compatible with the effective type of the
object,</li>
<li>a type that is the signed or unsigned type corresponding to the effective type
of the object,</li>
<li>a type that is the signed or unsigned type corresponding to a qualified</li>
<li>version of the effective type of the object,</li>
<li>an aggregate or union type that includes one of the aforementioned types among
its members (including, recursively, a member of a subaggregate or contained
union), or a character type.</li>
</ul>
<p>A floating expression may be contracted, that is, evaluated as though it were
an atomic operation, thereby omitting rounding errors implied by the source code
and the expression evaluation method. A contracted expression might also omit
raising of floating-point exceptions. The <code class="docutils literal"><span class="pre">FP_CONTRACT</span></code> pragma in provides a
way to disallow contracted expressions. Otherwise, whether and how expressions
are contracted is implementation-defined.</p>
<div class="section" id="primary-expressions">
<span id="index-2"></span><h4>4.3.2.1. Primary Expressions<a class="headerlink" href="#primary-expressions" title="Permalink to this headline">¶</a></h4>
<p>An identifer is a primary expression, provided it has been decared as
designating an object (in which case it is an lvalue) or a function (in which
case it is a function designator). Thus, an undeclared identifire is a violation
of syntax.</p>
<p>A constant is a primary expression. Its type depends on its form and lvalue (A
value whose memory address can be taken. All variables except addresses
themselves fall in this category).</p>
<p>A string literal is a primary expression. It is an lvalue.</p>
<p>A parenthesized expression is a primary expression. Its type and value are
identical to those of upparenthesized expression. It is an lvalue, a function
designator, or a void expression if the unparenthesized expression is,
respectively, an lvalue, a function designator, or a void expression.</p>
</div>
</div>
<div class="section" id="operators">
<h3>4.3.3. Operators<a class="headerlink" href="#operators" title="Permalink to this headline">¶</a></h3>
<p>C is very rich in operators considering the fact that it is so old. So what I
will do is that divide them in groups and then study them. Each operator is
given in its own section to ease the navigation. After describing the operators
example programs are also given with their output and brief description as
always.</p>
</div>
<div class="section" id="additive-operators">
<span id="index-3"></span><h3>4.3.4. Additive Operators<a class="headerlink" href="#additive-operators" title="Permalink to this headline">¶</a></h3>
<p>There are two operators in this category. One you have seen in second chapter.
These are + and -.</p>
<p>For addition, either both the operands will have arithmetic type, or one operand
will be a pointer to an object type and the other will have integer type.
(Incrementing is equivalent to adding 1.) We will see pointer arithmetic in the
chapter dealing with pointers and arrays.</p>
<p>For subtraction following will hold:</p>
<ul class="simple">
<li>both operands have arithmetic type;</li>
<li>both operands are pointers to qualified or unqualified versions of compatible
object types; or</li>
<li>the left operand is a pointer to an object type and the right operand has
integer type. (Decrementing is equivalent to subtracting 1.)</li>
</ul>
<p>If both operands have arithmetic type, the usual arithmetic conversions are
performed on them. The result of the binary + operator is the sum of the
operands. The result of the binary - operator is the difference resulting from
the subtraction of the second operand from the first. There is also something
called pointer arithmetic which we will see in Chapter 6 describing pointers and
arrays.</p>
</div>
<div class="section" id="multiplicative-operators">
<span id="index-4"></span><h3>4.3.5. Multiplicative Operators<a class="headerlink" href="#multiplicative-operators" title="Permalink to this headline">¶</a></h3>
<p>There are three multiplicative operators. These are *, / and %. Each of the
operands for these operands will have arithmetic type. That is character string
cannot participate. The operands of % will have interger type. The usual
arithmetic conversion are performed on the operands. The result of binary *
operator is the product of operands. The result of the / operator is the
quotient from the division; the result of the % operator is the remainder. In
both the operations, if denominator is zero, the behavior is undefined. When
integers are divided, the result of / operator is the algebraic quotient with
any fractional parts discarded. This is often called &#8220;truncation towards zero&#8221;.
Let us see a small program demonstrating these five arithmetic operators:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">// Arithmetic operators</span>
<span class="c1">// Author: Shiv S. Dayal</span>
<span class="c1">// Description: Demo of arithmetic operators</span>

<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">f</span><span class="o">=</span> <span class="mf">6.45</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="sc">&#39;A&#39;</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">iResult</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">fResult</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">cResult</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

  <span class="n">cResult</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;cResult = %c</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cResult</span><span class="p">);</span>
  <span class="n">cResult</span> <span class="o">=</span> <span class="n">cResult</span> <span class="o">-</span> <span class="mi">5</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;cResult = %c</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cResult</span><span class="p">);</span>

  <span class="n">iResult</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">10</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;iResult = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">iResult</span><span class="p">);</span>
  <span class="n">iResult</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">c</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;iResult = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">iResult</span><span class="p">);</span>
  <span class="n">iResult</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">c</span><span class="p">)</span><span class="o">/</span><span class="mi">3</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Result = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">iResult</span><span class="p">);</span>
  <span class="n">iResult</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">c</span><span class="p">)</span><span class="o">%</span><span class="mi">2</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;iesult = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">iResult</span><span class="p">);</span>

  <span class="n">fResult</span> <span class="o">=</span> <span class="n">f</span> <span class="o">*</span> <span class="mf">2.12</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;fesult = %f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fResult</span><span class="p">);</span>
  <span class="n">fResult</span> <span class="o">=</span> <span class="n">f</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;fesult = %f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fResult</span><span class="p">);</span>
  <span class="n">fResult</span> <span class="o">=</span> <span class="n">f</span> <span class="o">/</span> <span class="mf">1.12</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;fesult = %f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fResult</span><span class="p">);</span>
  <span class="n">fResult</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">%</span> <span class="mi">3</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;fesult = %f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fResult</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>and the output is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">cResult</span> <span class="o">=</span> <span class="n">K</span>
<span class="n">cResult</span> <span class="o">=</span> <span class="n">F</span>
<span class="n">iResult</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">iResult</span> <span class="o">=</span> <span class="mi">650</span>
<span class="n">Result</span> <span class="o">=</span> <span class="mi">25</span>
<span class="n">iesult</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">fesult</span> <span class="o">=</span> <span class="mf">13.674000</span>
<span class="n">fesult</span> <span class="o">=</span> <span class="o">-</span><span class="mf">3.550000</span>
<span class="n">fesult</span> <span class="o">=</span> <span class="mf">5.758928</span>
<span class="n">fesult</span> <span class="o">=</span> <span class="mf">1.000000</span>
</pre></div>
</div>
<p>First cResult is sumof <code class="docutils literal"><span class="pre">'A'</span> <span class="pre">+</span> <span class="pre">i</span></code> which is <code class="docutils literal"><span class="pre">'K'</span></code> as <code class="docutils literal"><span class="pre">'K'</span></code> comes ten
positions after <code class="docutils literal"><span class="pre">A</span></code> in ASCII table. Then we subtract five and go back to
<code class="docutils literal"><span class="pre">F</span></code>.</p>
<p>First iReasult is <code class="docutils literal"><span class="pre">10</span> <span class="pre">-</span> <span class="pre">i</span></code> where value of <code class="docutils literal"><span class="pre">i</span></code> is <code class="docutils literal"><span class="pre">10</span></code> hence result is
<code class="docutils literal"><span class="pre">0</span></code>. Next we multiply it with <code class="docutils literal"><span class="pre">c</span></code> which contains <code class="docutils literal"><span class="pre">'A'</span></code> who has got ASCII
value of <code class="docutils literal"><span class="pre">65</span></code> and result becomes <code class="docutils literal"><span class="pre">650</span></code>. Then We take sum of <code class="docutils literal"><span class="pre">'A'</span></code> and
<code class="docutils literal"><span class="pre">i</span></code> and divide by <code class="docutils literal"><span class="pre">3</span></code> so the result is <code class="docutils literal"><span class="pre">25</span></code> as it is a division of <code class="docutils literal"><span class="pre">75</span></code>
by <code class="docutils literal"><span class="pre">3</span></code>. Next we use modulus operator and remainder is <code class="docutils literal"><span class="pre">1</span></code>. Note that in case
of / and % if denominator is zero the behavior is undefined.</p>
<p>Same way you can udnerstand floating-point operations. Note that you cannot use
modulus operator if either of the operands are floating-point numbers as it will
make no sense because of data type promotion rules. Here data type promotion
rule says smaller data types will be converted to bigger data types. Also, if
there is a data type on left side of assignment the result of applying the
operator to operands will be converted to the type of that. chars are promoted
to ints, ints are promoted to floats anf floats to double. The point is that
conversion will try to keep as much data as possible.</p>
</div>
<div class="section" id="relational-operators">
<span id="index-5"></span><h3>4.3.6. Relational Operators<a class="headerlink" href="#relational-operators" title="Permalink to this headline">¶</a></h3>
<p>There are four relational operators: &lt;, &gt;, &lt;= and &gt;=. One of the following will
be true for these operators:</p>
<ul class="simple">
<li>both operands have real type;</li>
<li>both operands are pointers to qualified or unqualified versions of compatible
object types (types that fully describe onjects; we will see pointers later);
or</li>
<li>both operands are pointers to qualified or unqualified versions of compatible
incomplete types (types that describe onjects but lack information needed to
determine their size).</li>
<li>If both the operands have arithmetic type, the usual arithmetic convrsions are
performed.</li>
<li>For the purposes of these operators, a pointer to an object that is not an
element of an array behaves the same as a pointer to the first element of an
array of length onr with the type of the object as its element type.</li>
<li>When two pointers are compared, the result depends on the relative locations
in the address space of the objects pointed to. If two pointers to object or
incomplete types both point to the same object, or both point one past the
last element of the same array object, they compare equal. If the objects
pointed to are members of the same aggregate object, pointers to structure
members declared later compare greater than pointers to members declared
earlier in the structure, and pointers to array elements with larger
subscript values compare greater than pointers to elements of the same array
with lower subscript values. All pointers to members of the same union object
compare equal. If the expression <code class="docutils literal"><span class="pre">P</span></code> points to an element of an array object
and the expression <code class="docutils literal"><span class="pre">Q</span></code> points to the last element of the same array object,
the pointer expression <code class="docutils literal"><span class="pre">Q+1</span></code> compares greater than <code class="docutils literal"><span class="pre">P</span></code>. In all other
cases, the behavior is undefined.</li>
<li>Each of the operators <code class="docutils literal"><span class="pre">&lt;</span></code> (less than), <code class="docutils literal"><span class="pre">&gt;</span></code> (greater than), <code class="docutils literal"><span class="pre">&lt;=</span></code> (less
than or equal to), and <code class="docutils literal"><span class="pre">&gt;=</span></code> (greater than or equal to) will yield 1 if the
specified relation is true and 0 if it is false. The expression a&lt;b&lt;c is not
implemented as in ordinary mathematics. As the syntax indicates, it means
(a&lt;b)&lt;c. The result has type int.</li>
</ul>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">// Author : Shiv S. Dayal</span>
<span class="c1">// Description : Demo of relational operator</span>

<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdbool.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="kt">_Bool</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">result</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>

  <span class="n">result</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">j</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>

  <span class="n">result</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>

  <span class="n">result</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">j</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>and the output is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="mi">1</span>
<span class="mi">0</span>
<span class="mi">1</span>
<span class="mi">0</span>
</pre></div>
</div>
<p>Note that you should not apply these to floating-point data types as they may
not be represented correctly and two different entities have the same internal
representation.</p>
</div>
<div class="section" id="equality-operators">
<span id="index-6"></span><h3>4.3.7. Equality Operators<a class="headerlink" href="#equality-operators" title="Permalink to this headline">¶</a></h3>
<p>There are two equlity operators == and !=. Following contraints apply to these:</p>
<ul class="simple">
<li>both operands have arithmetic type;</li>
<li>both operands are pointers to qualified or unqualified versions of compatible
types; or</li>
<li>one operand is a pointer to an object or incomplete type and the other is a</li>
<li>pointer to a qualified or unqualified version of void; or</li>
<li>one operand is a pointer and the other is a null pointer constant.</li>
</ul>
<p>Given below are semantics of these operators.</p>
<ul class="simple">
<li>The == (equal to) and != (not equal to) operators are analogous to the
relational operators except for their lower precedence. Because of the
precedences, a&lt;b == c&lt;d is 1 whenever a&lt;b and c&lt;d have the same truth-value.
Each of the operators yields 1 if the specified relation is true and 0 if it
is false. The result has type int. For any pair of operands, exactly one of
the relations is true.</li>
<li>If both of the operands have arithmetic type, the usual arithmetic conversions
are performed. Values of complex types are equal if and only if both their
real parts are equal and also their imaginary parts are equal. Any two values
of arithmetic types from different type domains are equal if and only if the
results of their conversions to the (complex) result type determined by the
usual arithmetic conversions are equal.</li>
<li>Otherwise, at least one operand is a pointer. If one operand is a pointer and
the other is a null pointer constant, the null pointer constant is converted
to the type of the pointer. If one operand is a pointer to an object or
incomplete type and the other is a pointer to a qualified or unqualified
version of void, the former is converted to the type of the latter.</li>
<li>Two pointers compare equal if and only if both are null pointers, both are
pointers to the same object (including a pointer to an object and a subobject
at its beginning) or function, both are pointers to one past the last element
of the same array object, or one is a pointer to one past the end of one array
object and the other is a pointer to the start of a different array object
that happens to immediately follow the first array object in the address
space.</li>
<li>For the purposes of these operators, a pointer to an object that is not an
element of an array behaves the same as a pointer to the first element of an
array of length one with the type of the object as its element type.</li>
</ul>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">// Author : Shiv S. Dayal</span>
<span class="c1">// Description : Demo of equality operator</span>

<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdbool.h&gt;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="kt">_Bool</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">result</span> <span class="o">=</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>

  <span class="n">result</span> <span class="o">=</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>and the output is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="mi">0</span>
<span class="mi">1</span>
</pre></div>
</div>
</div>
<div class="section" id="increment-and-decrement-operators">
<span id="index-7"></span><h3>4.3.8. Increment and Decrement Operators<a class="headerlink" href="#increment-and-decrement-operators" title="Permalink to this headline">¶</a></h3>
<p>There is one increment and one decrement operator. ++ and <code class="docutils literal"><span class="pre">--</span></code>. Both come
in two forms prefix and postfix. First we will see prefix versions then postfix
ones. There is only one constraint on prefix operators of these and that is the
operand of the prefix increment or decrement operator will have qualified or
unqualified real or pointer type and will be a modifiable lvalue.</p>
<p>The value of the operand of prefix ++ operator is incremented. The result is the
new value of the operand after incrementation. The ++E is equivalent to (E +=
1).</p>
<p>The prefix &#8211; operator is analogous to the prefix ++ operator except that the
value of the operand is decremented. Now we will see postfix ones; the
constraints are the same as prefix ones.</p>
<p>The result of the postfix ++ operator is the value of the operand. As a side
effect, the value of the operand object is incremented (that is, the value 1 of
the appropriate type is added to it). The value computation of the result is
sequenced before the side effect of updating the stored value of the operand.
With respect to an indeterminately-sequenced function call, the operation of
postfix ++ is a single evaluation. The prefix <code class="docutils literal"><span class="pre">--</span></code> operator is analogous
to the prefix ++ operator except that the value of the operand is incremented.
Here is the demo:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">// Author : Shiv S. Dayal</span>
<span class="c1">// Description : Demo of increment decrement operators</span>

<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">float</span> <span class="n">f</span> <span class="o">=</span> <span class="mf">7.123</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">++</span><span class="n">f</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">--</span><span class="n">f</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">f</span><span class="o">++</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">f</span><span class="o">--</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>and the output is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="mf">8.123000</span>
<span class="mf">7.123000</span>
<span class="mf">7.123000</span>
<span class="mf">8.123000</span>
<span class="mf">7.123000</span>
</pre></div>
</div>
</div>
<div class="section" id="logical-operators">
<span id="index-8"></span><h3>4.3.9. Logical Operators<a class="headerlink" href="#logical-operators" title="Permalink to this headline">¶</a></h3>
<p>There are two such operators. &amp;&amp; logical AND and || locical OR. Both the
operators have the same constraints and it is that both the operands will have
scalar type.</p>
<p>The &amp;&amp; operator gives 1 if both the operands are non-zero else 0. The result type
is <strong>int</strong>. It is different from bitwise &amp; operator in the sense that it
guarantess left-to-right evaluation; if the second operand is evaluated, there is
a sequence point between the evaluations of the first and second operands. If the
first operand is 0 then the second operand is not evaluated. This is known as
&#8220;short-circuit evaluation&#8221;.</p>
<p>The || operator gives 1 if any of operands are non-zero else it gives 0. Same as
logical AND operator and unlike bitwise | operator it guarantees left-to-right
evaluation and same goes for sequence points. If first operand is non-zero, the
second is not evaluated.</p>
<div class="highlight-c"><div class="highlight"><pre>      <span class="c1">// Author : Shiv S. Dayal</span>
<span class="c1">// Description : Demo of logical AND &amp; OR operators</span>

<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdbool.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">result</span><span class="p">;</span>

  <span class="n">result</span> <span class="o">=</span> <span class="n">i</span><span class="o">&amp;&amp;</span><span class="n">j</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>

  <span class="n">result</span> <span class="o">=</span> <span class="n">i</span><span class="o">||</span><span class="n">j</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>

  <span class="n">result</span> <span class="o">=</span> <span class="n">k</span><span class="o">&amp;&amp;</span><span class="n">j</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>

  <span class="n">result</span> <span class="o">=</span> <span class="n">k</span><span class="o">||</span><span class="n">j</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>and the output is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="mi">1</span>
<span class="mi">1</span>
<span class="mi">0</span>
<span class="mi">1</span>
</pre></div>
</div>
<p>note the use of <strong>bool</strong> here instead of <strong>_Bool</strong>.</p>
</div>
<div class="section" id="bitwise-operators">
<span id="index-9"></span><h3>4.3.10. Bitwise Operators<a class="headerlink" href="#bitwise-operators" title="Permalink to this headline">¶</a></h3>
<p>There are three bitwise operators. &amp;, |, and ^. AND, OR and EX-OR respectively.
OR is also called inclusive OR. These have the same contsraints and it is that
operands should be integer types. The usual arithmetic conversions are performed
on the operands.</p>
<p>The result of bianry &amp; is the bitwise AND of operands (that is, each bit in the
result is set if and only if each of the corresponding bits in the operands is
set.)</p>
<p>The result of the ^ operator is the bitwise exclusive OR of the operands (that
is, each bit in the result is set if and only if exactly one of the corresponding
bits in the converted operands is set).</p>
<p>The result of the | operator is the bitwise inclusive OR of the operands (that
is, each bit in the result is set if and only if at least one of the
corresponding bits in the converted operands is set).</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">// Author : Shiv S. Dayal</span>
<span class="c1">// Description : Demo of bitwise operators</span>

<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdbool.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

  <span class="n">result</span> <span class="o">=</span> <span class="n">i</span><span class="o">&amp;</span><span class="n">j</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>

  <span class="n">result</span> <span class="o">=</span> <span class="n">i</span><span class="o">|</span><span class="n">j</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>

  <span class="n">result</span> <span class="o">=</span> <span class="n">i</span><span class="o">^</span><span class="n">j</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>and the output is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="mi">4</span>
<span class="mi">5</span>
<span class="mi">1</span>
</pre></div>
</div>
</div>
<div class="section" id="bitwise-shift-operators">
<span id="index-10"></span><h3>4.3.11. Bitwise Shift Operators<a class="headerlink" href="#bitwise-shift-operators" title="Permalink to this headline">¶</a></h3>
<p>The constraint is same as other bitwise operators that operands should be
integers. The integer promotions are performed on each of the operands. The type
of the result if that of the promoted left operand. If the value of the right
operand is negative or is greater than or equal to the width of the promoted left
operand, the behavior is undefined.</p>
<p>The result of E1 &lt;&lt; E2 is E1 left-shifted E2 bit-positions; vacated
bits are filled with zeros. If E1 has an unsigned type, the value of the
result is <span class="math">\(E1 * 2^{E2}\)</span> , reduced modulo one more than the maximum value
representable in the reasult type. If E1 has a signed type and and
nonnegative value, and <span class="math">\(E1 * 2^{E2}\)</span>  is representable in the result type,
then that is the resulting value; otherwise the behavior is undefined.</p>
<p>The result of E1 &gt;&gt; E2 is E1 right-shifted E2 bit-positions. If
E1 has an unsigned type or if E1 has a signed type and a nonegative
value, the value of the result is the integral part of the quotient of
<span class="math">\(E1/2^{E2}\)</span>. If E1 has a signed type and a negative value, the
resulting value is implementation-defined.</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">// Author : Shiv S. Dayal</span>
<span class="c1">// Description : Demo of shift operators</span>

<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span>  <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span><span class="sc">&#39;A&#39;</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

  <span class="n">result</span> <span class="o">=</span> <span class="n">c</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>

  <span class="n">result</span> <span class="o">=</span> <span class="n">c</span><span class="o">&gt;&gt;</span><span class="n">i</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="assignment-operators">
<span id="index-11"></span><h3>4.3.12. Assignment Operators<a class="headerlink" href="#assignment-operators" title="Permalink to this headline">¶</a></h3>
<p>These are = *= /= %= += -= &lt;&lt;= &gt;&gt;= &amp;= ^= and |= The only constraint is that
left operand should be modifiable lvalue. An assignment operator stores a value
in the object designated by the left operand. An assignment expression has the
value of the left operand after the assignment, but is not an lvalue. The type of
an assignment expression is the type of the left operand unless the left operand
has qualified type, in which case it is the unqualified version of the type of
the left operand. The side effect of updating the stored value of the left
operand is sequenced after the value computations of the left and right operands.
The evaluations of the operands are unsequenced.</p>
<div class="section" id="simple-assignment">
<span id="index-12"></span><h4>4.3.12.1. Simple Assignment<a class="headerlink" href="#simple-assignment" title="Permalink to this headline">¶</a></h4>
<p>One of the following will hold:</p>
<ul class="simple">
<li>the left operand has qualified or unqualified arithmetic type and the right has
arithmetic type;</li>
<li>the left operand has a qualified or unqualified version of a structure or union  type compatible with the type of the right;</li>
<li>both operands are pointers to qualified or unqualified versions of compatible
types, and the type pointed to by the left has all the qualifiers of the type
pointed to by the right;</li>
<li>one operand is a pointer to an object or incomplete type and the other is a
pointer to a qualified or unqualified version of void, and the type pointed to
by the left has all the qualifiers of the type pointed to by the right;</li>
<li>the left operand is a pointer and the right is a null pointer constant; or</li>
<li>the left operand has type _Bool and the right is a pointer.</li>
</ul>
<p>In simple assignment (=), the value of the right operand is converted to the type
of the assignment expression and replaces the value stored in the object
designated by the left operand.</p>
<p>If the value being stored in an object is read from another object that overlaps
in any way the storage of the first object, then the overlap will be exact and
the two objects will have qualified or unqualified versions of a compatible type;
otherwise, the behavior is undefined.</p>
</div>
<div class="section" id="compound-assignment">
<span id="index-13"></span><h4>4.3.12.2. Compound Assignment<a class="headerlink" href="#compound-assignment" title="Permalink to this headline">¶</a></h4>
<p>For the operators += and -= only, either the left operand will be a pointer to an
object type and the right will have integer type, or the left operand will have
qualified or unqualified arithmetic type and the right will have arithmetic type.
For the other operators, each operand will have arithmetic type consistent with
those allowed by the corresponding binary operator.</p>
<p>A compound assignment of the form E1 op= E2 is equivalent to the simple
assignment expression E1 = E1 op (E2), except that the lvalue E1 is evaluated
only once, and with respect to an indeterminately-sequenced function call, the
operation of a compound assignment is a single evaluation.</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">// Author: Shiv S. Dayal</span>
<span class="c1">// Description: Demo of compound assignments.</span>

<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span>   <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">j</span>   <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">f</span> <span class="o">=</span> <span class="mf">4.7</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">result</span><span class="o">=</span><span class="mf">0.0</span><span class="p">;</span>

  <span class="n">result</span> <span class="o">+=</span> <span class="n">i</span><span class="o">+</span><span class="n">f</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>

  <span class="n">result</span> <span class="o">-=</span> <span class="n">f</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>

  <span class="n">j</span> <span class="o">&lt;&lt;=</span> <span class="n">i</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>and the output is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="mf">7.700000</span>
<span class="mf">3.000000</span>
<span class="mi">24</span>
</pre></div>
</div>
</div>
<div class="section" id="conditoinal-operators">
<span id="index-14"></span><h4>4.3.12.3. Conditoinal Operators<a class="headerlink" href="#conditoinal-operators" title="Permalink to this headline">¶</a></h4>
<p>It has the following form: E1 ? E2 :E3;. If E1 is true then E2 is assigned to
lvalue else E2 is assigned. It has following constraints:</p>
<ul class="simple">
<li>The first operand will have scalar type.</li>
<li>One of the following will hold for the second and third operands:<ul>
<li>both operands have arithmetic type;</li>
<li>both opearands have the same structure or union type;</li>
<li>both operands have void type;</li>
<li>both operands are pointers to qualified or unqualified versions of compatible
types;</li>
<li>one operand is a pointer and the other is a null pointer constant; or</li>
<li>one operand is a pointer to an object or incomplete type and the other is a
pointer to a qualified or unqualified version of void.</li>
</ul>
</li>
</ul>
<p>The first operand is evaluated; there is a sequence point between its evaluation
and the evaluation of the second or third operand (whichever is evaluated). The
second operand is evaluated only if the first compares unequal to 0; the third
operand is evaluated only if the first compares equal to 0; the result is the
value of the second or third operand (whichever is evaluated), converted to the
type described below. Note that a conditional expression does not give an lvalue.</p>
<p>If both the second and third operands have arithmetic type, the result type that
would be determined by the usual arithmetic conversions, were they applied to
those two operands, is the type of the result. If both the operands have
structure or union type, the result has that type. If both operands have void
type, the result has void type.</p>
<p>If both the second and third operands are pointers or one is a null pointer
constant and the other is a pointer, the result type is a pointer to a type
qualified with all the type qualifiers of the types pointed-to by both operands.
Furthermore, if both operands are pointers to compatible types or to differently qualified versions of compatible types, the result type is a pointer to an
appropriately qualified version of the composite type; if one operand is a null
pointer constant, the result has the type of the other operand; otherwise, one
operand is a pointer to void or a qualified version of void, in which case the
result type is a pointer to an appropriately qualified version of void.</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">// Author : Shiv S. Dayal</span>
<span class="c1">// Description : Demo of conditional operator</span>

<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">)</span><span class="o">?</span> <span class="mi">7</span><span class="o">:</span><span class="mi">10</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>output is 7 as 4 is less than 5 which is true.</p>
</div>
<div class="section" id="comma-operators">
<span id="index-15"></span><h4>4.3.12.4. Comma Operators<a class="headerlink" href="#comma-operators" title="Permalink to this headline">¶</a></h4>
<p>It is a very simple operator. The left operand of a comma operator is evaluated
as a void expression; there is a sequence point between its evaluation and that
of the right operand. Then the right operand is evaluated; the result has its
type and value. A comma operator does not give an lvalue.</p>
</div>
<div class="section" id="sizeof-operators">
<span id="index-16"></span><h4>4.3.12.5. sizeof Operators<a class="headerlink" href="#sizeof-operators" title="Permalink to this headline">¶</a></h4>
<p>You have already see sizeof operator in second chapter when we saw sizes of data
types. However here is the constraint: the sizeof operator will not be applied to
an expression that has function type or an incomplete type, to the parenthesized
name of such a type, or to an expression that designates a bit-field member.</p>
<p>The sizeof operator yields the size (in bytes) of its operand, which may be an
expression or the parenthesized name of a type. The size is determined from the
type of the operand. The result is an integer. If the type of the operand is a
variable length array type, the operand is evaluated; otherwise, the operand is
not evaluated and the result is an integer constant.</p>
<p>When applied to an operand that has type char, unsigned char, or signed char,
(or a qualified version thereof) the result is 1. When applied to an operand that
has array type, the result is the total number of bytes in the array. When
applied to an operand that has structure or union type, the result is the total
number of bytes in such an object, including internal and trailing padding.</p>
</div>
<div class="section" id="unary-arithmetic-operators">
<span id="index-17"></span><h4>4.3.12.6. Unary Arithmetic Operators<a class="headerlink" href="#unary-arithmetic-operators" title="Permalink to this headline">¶</a></h4>
<p>The operand of the unary + or - operator will have arithmetic type; of the ~
operator, integer type; of the ! operator, scalar type.</p>
<p>The result of the unary + operator is the value of its (promoted) operand. The
integer promotions are performed on the operand, and the result has the promoted
type.</p>
<p>The result of the unary - operator is the negative of its (promoted) operand. The
integer promotions are performed on the operand, and the result has the promoted
type.</p>
<p>The result of the ~ operator is the bitwise complement of its (promoted) operand
(that is, each bit in the result is set if and only if the corresponding bit in
the converted operand is not set). The integer promotions are performed on the
operand, and the result has the promoted type. If the promoted type is an
unsigned type, the expression ~E is equivalent to the maximum value representable
in that type minus E.</p>
<p>The result of the logical negation operator ! is 0 if the value of its operand compares
unequal to 0, 1 if the value of its operand compares equal to 0. Theresult has type
int. The expression !E is equivalent to (0==E).</p>
<p>We will see casting, array subscripting, function parenthes, address and
indirection operators later at appropriate time. For now I am going to tell you
about operator precedence and associativity and then about grouping parenthes.
Given below is the table for operator precedence and associativity, however, you
may not be familiar with few of them but later you will be:</p>
<table border="1" class="docutils" id="index-18">
<colgroup>
<col width="70%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Operators</th>
<th class="head">Associativity</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>() [] . -&gt; ++ &#8211; (postfix)</td>
<td>left-to-right</td>
</tr>
<tr class="row-odd"><td>++ &#8211; + - (unary) ! ~ (types) * &amp; sizeof</td>
<td>right-to-lfet</td>
</tr>
<tr class="row-even"><td>* / %</td>
<td>left-to-right</td>
</tr>
<tr class="row-odd"><td>+ - (Addition/Subtraction)</td>
<td>left-to-right</td>
</tr>
<tr class="row-even"><td>&lt;&lt; &gt;&gt;</td>
<td>left-to-right</td>
</tr>
<tr class="row-odd"><td>&lt; &gt; &lt;= &gt;=</td>
<td>left-to-right</td>
</tr>
<tr class="row-even"><td>== !=</td>
<td>left-to-right</td>
</tr>
<tr class="row-odd"><td>&amp;</td>
<td>left-to-right</td>
</tr>
<tr class="row-even"><td>^</td>
<td>left-to-right</td>
</tr>
<tr class="row-odd"><td>|</td>
<td>left-to-right</td>
</tr>
<tr class="row-even"><td>&amp;&amp;</td>
<td>left-to-right</td>
</tr>
<tr class="row-odd"><td>||</td>
<td>left-to-right</td>
</tr>
<tr class="row-even"><td>Assignement operators</td>
<td>right-to-left</td>
</tr>
<tr class="row-odd"><td>,</td>
<td>left-to-right</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="grouping-parentheses">
<span id="index-19"></span><h3>4.3.13. Grouping parentheses<a class="headerlink" href="#grouping-parentheses" title="Permalink to this headline">¶</a></h3>
<p>Grouping parentheses are used to override operator precedence and group
expressions. NEVER EVER try to memorize and rely on precedence of operators.
Always use grouping parentheses. Till now I have shown very simple examples of
operators; here are some complex ones:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">// Author: Shiv Shankar Dayal</span>
<span class="c1">// Description: Demo of grouping parentheses</span>

<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mf">5.2</span><span class="o">*</span><span class="p">(</span><span class="mf">3.7</span><span class="o">+</span><span class="mf">2.3</span><span class="p">));</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">((</span><span class="mi">4</span><span class="o">&amp;</span><span class="mi">5</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="mi">7</span><span class="o">^</span><span class="mi">5</span><span class="p">)));</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This small program shows you what can go wrong if you rely on memory. It allows
you do addition first and then multiplcation. Inner parentheses are evaluated
first then inner ones. This concludes our chapter on operators and expressions.
Next we focus on control statements and flow statements.</p>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../cf/" class="btn btn-neutral float-right" title="5. Control Flow" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../io/" class="btn btn-neutral" title="3. Console I/O" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2012-2015, Shiv S. Dayal.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>