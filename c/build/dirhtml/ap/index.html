

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-17487464-6']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>6. Arrays and Pointers &mdash; C Programming  documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="C Programming  documentation" href="../"/>
        <link rel="next" title="7. Functions" href="../func/"/>
        <link rel="prev" title="5. Control Flow" href="../cf/"/>
<link rel="stylesheet" href="../../css/math.css" type="text/css" />


  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../" class="icon icon-home"> C Programming
          

          
          </a>

          
            
            
              <div class="version">
                0.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search/" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../introduction/">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../basics/">2. Basics of C</a></li>
<li class="toctree-l1"><a class="reference internal" href="../io/">3. Console I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="../oae/">4. Operators and Expressions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cf/">5. Control Flow</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">6. Arrays and Pointers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#single-dimensional-array">6.1. Single-Dimensional Array</a></li>
<li class="toctree-l2"><a class="reference internal" href="#multi-dimensional-array">6.2. Multi-Dimensional Array</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pointers">6.3. Pointers</a></li>
<li class="toctree-l2"><a class="reference internal" href="#address-and-indirection-operators">6.4. Address and Indirection Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="#arrays-of-pointers">6.5. Arrays of Pointers</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pointers-of-pointers">6.6. Pointers of Pointers</a></li>
<li class="toctree-l2"><a class="reference internal" href="#realloc-function">6.7. realloc() Function</a></li>
<li class="toctree-l2"><a class="reference internal" href="#free-function">6.8. free() Function</a></li>
<li class="toctree-l2"><a class="reference internal" href="#constness">6.9. Constness</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../func/">7. Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../su/">8. Structures and Unions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../strings/">9. Strings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fileio/">10. File Input/Output</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fs/">11. Following Specification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../env/">12. Environment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lang/">13. Language</a></li>
<li class="toctree-l1"><a class="reference internal" href="../macros/">14. Preprocessing Directives</a></li>
<li class="toctree-l1"><a class="reference internal" href="../std/">15. The C Standard Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../assert/">16. Diagnostics <code class="docutils literal"><span class="pre">&lt;assert.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../complex/">17. Complex arithmetic <code class="docutils literal"><span class="pre">&lt;complex.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../ctypes/">18. Character Handling <code class="docutils literal"><span class="pre">&lt;ctype.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../errno/">19. Errors <code class="docutils literal"><span class="pre">&lt;errno.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../fenv/">20. Floating-point environment <code class="docutils literal"><span class="pre">&lt;fenv.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../float/">21. Characteristics of floating types <code class="docutils literal"><span class="pre">&lt;float.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../inttypes/">22. Format conversion of integer types <code class="docutils literal"><span class="pre">&lt;inttypes.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../iso646/">23. Alternative spellings <code class="docutils literal"><span class="pre">&lt;iso646.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../limits/">24. Sizes of integer types <code class="docutils literal"><span class="pre">&lt;limits.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../locale/">25. Localization &lt;locale.h&gt;</a></li>
<li class="toctree-l1"><a class="reference internal" href="../math/">26. Mathematics <code class="docutils literal"><span class="pre">&lt;math.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../setjmp/">27. Nonlocal jumps <code class="docutils literal"><span class="pre">&lt;setjmp.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../signal/">28. Signal handling <code class="docutils literal"><span class="pre">&lt;signal.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../stdarg/">29. Variable arguments <code class="docutils literal"><span class="pre">&lt;stdarg.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../stdbool/">30. Boolean type and values <code class="docutils literal"><span class="pre">&lt;stdbool.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../stddef/">31. Common definitions <code class="docutils literal"><span class="pre">&lt;stddef.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../stdint/">32. Integer types <code class="docutils literal"><span class="pre">&lt;stdint.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../stdio/">33. Input/output <code class="docutils literal"><span class="pre">&lt;stdio.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../stdlib/">34. General utilities <code class="docutils literal"><span class="pre">&lt;stdlib.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../string/">35. String handling <code class="docutils literal"><span class="pre">&lt;string.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../tgmath/">36. Type-generic math <code class="docutils literal"><span class="pre">&lt;tgmath.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../time/">37. Date and time <code class="docutils literal"><span class="pre">&lt;time.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../wchar/">38. Extended multibyte and wide character utilities <code class="docutils literal"><span class="pre">&lt;wchar.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../wtype/">39. Wide character classification and mapping utilities <code class="docutils literal"><span class="pre">&lt;wctype.h&gt;</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../problems/">40. Problems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../license/">41. License</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../">C Programming</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../">Docs</a> &raquo;</li>
      
    <li>6. Arrays and Pointers</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/ap.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="arrays-and-pointers">
<h1>6. Arrays and Pointers<a class="headerlink" href="#arrays-and-pointers" title="Permalink to this headline">¶</a></h1>
<p>In this chapter I am going to tell you about two very powerful constructs of C
programming; arrays and pointers. Arrays are what they are; array of some data
type. There can be an array of any complete type. You cannot create an array of
any incomplete type, therefore, an array of type void is not allowed. There are
fixed arrays and also variable length arrays. C99 inroduced variable length
arrays before that arrays were only of fixed length. However, you can increase
the capacity of a fixed sized array using <code class="docutils literal"><span class="pre">realloc()</span></code> function. There is
single-dimensional array and then there is multi-dimensional array. We will
first go through single-dimensional array then multi-dimensional.</p>
<div class="section" id="single-dimensional-array">
<span id="index-0"></span><h2>6.1. Single-Dimensional Array<a class="headerlink" href="#single-dimensional-array" title="Permalink to this headline">¶</a></h2>
<p>Let us first create a basic array and then see how to access it elements:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">//Author: Shiv S. Dayal</span>
<span class="c1">//Description : Demo of array.</span>

<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">MAX</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
  <span class="c1">//An initialized array</span>
  <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
  <span class="c1">//An initialized array to 0</span>
  <span class="kt">int</span> <span class="n">b</span><span class="p">[</span><span class="n">MAX</span><span class="p">];</span>

  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;b[%d]=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="p">}</span>

  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;a[%d]=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>and the output is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
<span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
<span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="mi">2</span>
<span class="n">b</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">=</span><span class="mi">3</span>
<span class="n">b</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">=</span><span class="mi">4</span>
<span class="n">b</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">=</span><span class="mi">5</span>
<span class="n">b</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="o">=</span><span class="mi">6</span>
<span class="n">b</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="o">=</span><span class="mi">7</span>
<span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
<span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
<span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
<span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
<span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
<span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
<span class="n">a</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
<span class="n">a</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
</pre></div>
</div>
<p>Here you see array subscripting operator in action. I have not covered this
particular operator in fourth chapter so it becomes my duty to explain it here.
There are two parts here one outside subscript and another outside. The
expression which is outside will have type &#8220;const pointer to object type&#8221;. This
means that array&#8217;s base address is fixed and cannot be changes. The expression
which is inside will have integer type. The result of these two has type &#8220;type&#8221;.
We will see pointer arithmetic with binary + operator in the pointers section
which is equivalent to subscript expression.</p>
<p>As you can see array <code class="docutils literal"><span class="pre">a</span></code> is fixed length array while array <code class="docutils literal"><span class="pre">b</span></code> is a variable
length array. You are not allowed to initialize variable length arrays at the
time of declaration. Notice that array indices do not start from 1 but 0. Never
ever make the mistake of thinking that array indices start from 1. You can also
initialize an array as <code class="docutils literal"><span class="pre">a[]={1,</span> <span class="pre">2,</span> <span class="pre">3};</span></code> or <code class="docutils literal"><span class="pre">a[3]={1,</span> <span class="pre">2,</span> <span class="pre">3};</span></code>. The array
elements would be <code class="docutils literal"><span class="pre">a[0],</span> <span class="pre">a[1]</span></code> and <code class="docutils literal"><span class="pre">a[2]</span></code> in both the cases. Notice how
assignment is done to elements of second array inside for loop one by one using
the bracket operator or subscripting operator. The array elements are always in
sequence in memory. A conceptual diagram is given below for first three elements
of above array. Here 1 means first element.</p>
<a class="reference internal image-reference" href="../_images/arraydia.png" id="index-1"><img alt="Memory diagram of an array." class="align-center" id="index-1" src="../_images/arraydia.png" /></a>
<p id="index-2">Array elements are always(not always but most commonly. It is so coomon that I
have used always.) accessed using their indices so order of retrieval is
<em>O(1)</em>.(This is known as big-O notation. You can find it in any Data Structure
and Algorithm book. If you wait you can find in my book as well but you should
not. :-)) The above program will not compile using old compilers which do not
support C99 standard like Turbo C++. Also, you may require to pass the flag
-std=c99 to some versions of gcc. For variable length arrays it is not necessary
to declare the size in advance. Even, input to program from other sources will
do.</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">//Author: Shiv S. Dayal</span>
<span class="c1">//Description : Demo of array.</span>

<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Enter the value of i:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>

  <span class="kt">char</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Enter a string which contains one less no. of chars than i:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">gets</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
  <span class="n">puts</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>and the output is:</p>
<div class="highlight-python"><div class="highlight"><pre>Enter the value of i:
6
shiv
Enter a string which contains one less no. of chars than i:
shiv
shiv
</pre></div>
</div>
<p>As you can see variable length array should be declared after the size is known
otherwise you may see strange output even though it is not compilation error.
For example you could have declaraed array immediately after <code class="docutils literal"><span class="pre">i</span></code> but you will
get some garbage output. The reason for this is that at that point of time <code class="docutils literal"><span class="pre">i</span></code>
contains garbage value. Also, note that array indices are integers.
Floating-point numbers or variables cannot be indices.</p>
<p>Let us say you are writing a big piece of code and array is declared somewhere
and you want to know how many elemnets you can fill in the array or what is the
maximum size of array then you can use the following program:</p>
<div class="highlight-c" id="index-3"><div class="highlight"><pre><span class="c1">//Author: Shiv S. Dayal</span>
<span class="c1">//Description : Demo of array.</span>

<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">float</span> <span class="n">f</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="mf">0.0</span><span class="p">};</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Size of array f is %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>output:</p>
<div class="highlight-python"><div class="highlight"><pre>Size of array f is 10.
</pre></div>
</div>
<p>Now an experienced programmer may ask that if we can know the size of array then
why we do not have something like out of bounds exception of Java in C. My
answer to that is C was written in 1970 and Java in 1990. For example, there are
certain compilers with flags which help you detect this at runtime.</p>
<p>Feel free to experiment with arrays. Do whatever you like. Remember the more you
will experiment the more you will learn. There are various ways in which you can
define character arrays. For example, <code class="docutils literal"><span class="pre">char</span> <span class="pre">c[6]={'h',</span> <span class="pre">'e',</span> <span class="pre">'l',</span> <span class="pre">'l',</span> <span class="pre">'o',</span>
<span class="pre">'\0'};</span></code>. Remember, you must terminate a character array with a null terminator.
Another way to define the same is: <code class="docutils literal"><span class="pre">char</span> <span class="pre">str[6]</span> <span class="pre">=</span> <span class="pre">&quot;hello&quot;;</span></code>. In this example
you do not need to add <code class="docutils literal"><span class="pre">'\0'</span></code> explicitly as it is added automatically. Also,
6 is optional here if you want you can ommit that. Of course second example is
more preferable. Note that if you declare an array of size <code class="docutils literal"><span class="pre">m</span></code> and data type
size of array is <code class="docutils literal"><span class="pre">n</span></code> bytes then the array will consume <code class="docutils literal"><span class="pre">m*n</span></code> bytes no matter
what; even when you are not using those bytes. Note that all these arrays are on
stack memory area. We will see how to allocate array on heap memory area once we
have studied pointers.</p>
</div>
<div class="section" id="multi-dimensional-array">
<span id="index-4"></span><h2>6.2. Multi-Dimensional Array<a class="headerlink" href="#multi-dimensional-array" title="Permalink to this headline">¶</a></h2>
<p>Arrays can be n-dmensional. There is no limit on dimensions. You can allocate as
much as your memory allows. We will begin with two-dimensional array. A
two-dimensional array looks like a matrix. Say a two-dimensional array has m as
one dimension and n as second diemnsion. Then total no. of elements will be m*n
and size occupied is m*m*size of data type of array. There are various ways to
initialize a two-dimensional array. Consider the following example:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">//Author: Shiv S. Dayal</span>
<span class="c1">//Description : Demo of two-dimensional array.</span>

<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">},{</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">}};</span>
  <span class="kt">int</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">};</span>

  <span class="c1">//iterating over array</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>output:</p>
<div class="highlight-python"><div class="highlight"><pre>1 2
3 4
1 2
3 4
</pre></div>
</div>
<p>Same way you can have multi-dimensional array. I leave it up to you to find
applications of different arrays. For now, try multiplying two matrices, doing a
transpose, inverse of a matrix and printing a yearly calenday for any year for
example. With the current information given to you, you should be able to do all
these easily. As shown for array <code class="docutils literal"><span class="pre">a</span></code> it is not really a single array but an
array of array. How we can read this is array a has two arrays each of which have
two integers.</p>
</div>
<div class="section" id="pointers">
<span id="index-5"></span><h2>6.3. Pointers<a class="headerlink" href="#pointers" title="Permalink to this headline">¶</a></h2>
<p>A pointer can store an address. A pointer of some type can store address of that
type and a pointer to void can store address of any type.</p>
<p>These are very interesting; considered to be one of the most powerful in the
hands of capable programmer and most dangerous tool in the hands of an ignorant
programmer. There are four standard library functions associated with them. All
these are declared in <strong>stdlib.h</strong> which is part of standard c library. The
functions are: <strong>malloc(), calloc(), realloc()</strong> and <strong>free()</strong>. Following is the
contents of man pages verbatim,later in the program you can go to opengroup links
as well. First signatures:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">void</span> <span class="o">*</span><span class="nf">calloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">nmemb</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">malloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">realloc</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
</pre></div>
</div>
<p id="index-6">here <code class="docutils literal"><span class="pre">size_t</span></code> is the unsigned integer type of the result of the <code class="docutils literal"><span class="pre">sizeof</span></code>
operator. It is defined in <code class="docutils literal"><span class="pre">stddef.h</span></code>. And now descriptions:</p>
<p><code class="docutils literal"><span class="pre">calloc()</span></code> allocates memory for an array of <code class="docutils literal"><span class="pre">nmemb</span></code> elements of size bytes
each and returns a pointer to the allocated memory. The memory is set to zero.
If <code class="docutils literal"><span class="pre">nmemb</span></code> or size is 0, then <code class="docutils literal"><span class="pre">calloc()</span></code> returns either <code class="docutils literal"><span class="pre">NULL</span></code>, or a unique
pointer value that can later be successfully passed to <code class="docutils literal"><span class="pre">free()</span></code>.</p>
<p><code class="docutils literal"><span class="pre">malloc()</span></code> allocates size bytes and returns a pointer to the allocated memory.
The memory is not cleared. If size is 0, then <code class="docutils literal"><span class="pre">malloc()</span></code> returns either
<code class="docutils literal"><span class="pre">NULL</span></code>, or a unique pointer value that can later be successfully passed to
<code class="docutils literal"><span class="pre">free()</span></code>.</p>
<p><code class="docutils literal"><span class="pre">free()</span></code> frees the memory space pointed to by <code class="docutils literal"><span class="pre">ptr</span></code>, which must have been
returned by a previous call to <code class="docutils literal"><span class="pre">malloc(),</span> <span class="pre">calloc()</span></code> or <code class="docutils literal"><span class="pre">realloc()</span></code>.
Otherwise, or if <code class="docutils literal"><span class="pre">free(ptr)</span></code> has already been called before, undefined behavior
occurs. If <code class="docutils literal"><span class="pre">ptr</span></code> is <code class="docutils literal"><span class="pre">NULL</span></code>, no operation is performed.</p>
<p><code class="docutils literal"><span class="pre">realloc()</span></code> changes the size of the memory block pointed to by <code class="docutils literal"><span class="pre">ptr</span></code> to
<code class="docutils literal"><span class="pre">size</span></code> bytes. The contents will be unchanged to the minimum of the old and new
sizes; newly allocated memory will be uninitialized. If <code class="docutils literal"><span class="pre">ptr</span></code> is <code class="docutils literal"><span class="pre">NULL</span></code>,
then the call is equivalent to <code class="docutils literal"><span class="pre">malloc(size)</span></code>, for all values of <code class="docutils literal"><span class="pre">size</span></code>; if
<code class="docutils literal"><span class="pre">size</span></code> is equal to zero, and <code class="docutils literal"><span class="pre">ptr</span></code> is not NULL, then the call is equivalent
to <code class="docutils literal"><span class="pre">free(ptr)</span></code>. Unless <code class="docutils literal"><span class="pre">ptr</span></code> is NULL, it must have been returned by an earlier call to <code class="docutils literal"><span class="pre">malloc(),</span> <span class="pre">calloc()</span></code> or <code class="docutils literal"><span class="pre">realloc()</span></code>. If the area pointed to
was moved, a <code class="docutils literal"><span class="pre">free(ptr)</span></code> is done.</p>
<p>Let us consider a program:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">//Author: Shiv S. Dayal</span>
<span class="c1">//Description : Demo of pointer.</span>

<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

  <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="mi">8</span><span class="p">);</span>

  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">=</span><span class="n">i</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Content at %dth location is %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="n">i</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>and the output is:</p>
<div class="highlight-python"><div class="highlight"><pre>Content at 0th location is 0.
Content at 1th location is 1.
Content at 2th location is 2.
Content at 3th location is 3.
Content at 4th location is 4.
Content at 5th location is 5.
Content at 6th location is 6.
Content at 7th location is 7.
</pre></div>
</div>
<p>There are various ways to declare a simple pointer and initialize it. For
example:</p>
<div class="highlight-c" id="index-7"><div class="highlight"><pre><span class="kt">char</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>                           <span class="c1">//Only declaration no initialization</span>
    <span class="n">c</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>                    <span class="c1">//Initialization</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>                    <span class="c1">//declaration and initialization</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="o">*</span><span class="mi">10</span><span class="p">);</span> <span class="c1">//Declare and allocate memory for 10</span>
</pre></div>
</div>
<p>On line number 15 and 16 you are seeing pointer arithmetic. Consider array <code class="docutils literal"><span class="pre">a</span></code>
declared in the first example. We could have iterated in that example like
<code class="docutils literal"><span class="pre">*(a+i)</span></code>.</p>
<p>A postfix expression followed by an expression in square brackets [] is a
subscripted designation of an element of an array object. The definition of the
subscript operator [] is that <code class="docutils literal"><span class="pre">E1[E2]</span></code> is identical to <code class="docutils literal"><span class="pre">(*((E1)+(E2)))</span></code>.
Because of the conversion rules that apply to the binary <code class="docutils literal"><span class="pre">+</span></code> operator, if
<code class="docutils literal"><span class="pre">E1</span></code> is an array object (equivalently, a pointer to the initial element of an
array object) and <code class="docutils literal"><span class="pre">E2</span></code> is an integer, <code class="docutils literal"><span class="pre">E1[E2]</span></code> designates the <code class="docutils literal"><span class="pre">E2</span></code>-th
element of of <code class="docutils literal"><span class="pre">E1</span></code> (counting from zero).</p>
<p>I had not covered some portion of additive operators in the chapter of operators
and expression deliberately as I wanted to discuss them here. When an expression
that has integer type is added to or subtracted from a pointer, the result has
the type of the pointer operand. If the pointer operand points to an element of
an array object, and the array is large enough, the result points to an element
offset from the original element such that the difference of the subscripts of
the resulting and original array elements equals the integer expression. In other
words, if the expression <code class="docutils literal"><span class="pre">P</span></code> points to the <code class="docutils literal"><span class="pre">i</span></code>-th element of an array object,
the expressions <code class="docutils literal"><span class="pre">(P)+N</span></code> (equivalently, <code class="docutils literal"><span class="pre">N+(P)</span></code>) and <code class="docutils literal"><span class="pre">(P)-N</span></code> (where <code class="docutils literal"><span class="pre">N</span></code>
has the value <code class="docutils literal"><span class="pre">n</span></code>) point to, respectively, the <code class="docutils literal"><span class="pre">i+n</span></code>-th and <code class="docutils literal"><span class="pre">i-n</span></code>-th
elements of the array object, provided they exist. Moreover, if the expression
<code class="docutils literal"><span class="pre">P</span></code> points to the last element of an array object, the expression <code class="docutils literal"><span class="pre">(P)+1</span></code>
points one past the last element of the array object, and if the expression
<code class="docutils literal"><span class="pre">Q</span></code> points one past the last element of an array object, the expression
<code class="docutils literal"><span class="pre">(Q)-1</span></code> points to the last element of the array object. If both the pointer
operand and the result point to elements of the same array object, or one past
the last element of the array object, the evaluation will not produce an
overflow; otherwise, the behavior is undefined. If the result points one past
the last element of the array object, it will not be used as the operand of a
unary <code class="docutils literal"><span class="pre">*</span></code> operator that is evaluated.</p>
<p>When two pointers are subtracted, both shall point to elements of the same array
object, or one past the last element of the array object; the result is the
difference of the subscripts of the two array elements. The size of the result is
implementation-defined, and its type (a signed integer type) is <code class="docutils literal"><span class="pre">ptrdiff_t</span></code>
defined in the <code class="docutils literal"><span class="pre">&lt;stddef.h&gt;</span></code> header. If the result is not representable in an
object of that type, the behavior is undefined. In other words, if the
expressions <code class="docutils literal"><span class="pre">P</span></code> and <code class="docutils literal"><span class="pre">Q</span></code> point to, respectively, the <code class="docutils literal"><span class="pre">i</span></code>-th and <code class="docutils literal"><span class="pre">j</span></code>-th
elements of an array object, the expression <code class="docutils literal"><span class="pre">(P)-(Q)</span></code> has the value <code class="docutils literal"><span class="pre">i-j</span></code>
provided the value fits in an object of type <code class="docutils literal"><span class="pre">ptrdiff_t</span></code>. Moreover, if the
expression <code class="docutils literal"><span class="pre">P</span></code> points either to an element of an array object or one past the
last element of an array object, and the expression <code class="docutils literal"><span class="pre">Q</span></code> points to the last
element of the same array object, the expression <code class="docutils literal"><span class="pre">((Q)+1)-(P)</span></code> has the
same value as <code class="docutils literal"><span class="pre">((Q)-(P))+1</span></code> and as <code class="docutils literal"><span class="pre">-((P)-((Q)+1))</span></code>, and has the value zero
if the expression <code class="docutils literal"><span class="pre">P</span></code> points one past the last element of the array object,
even though the expression <code class="docutils literal"><span class="pre">(Q)+1</span></code> does not point to an element of the array
object.</p>
<p>You can also apply increment and decrement operators on pointers. I will show
you a reimplementation of previos program using increment operators:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">//Author: Shiv S. Dayal</span>
<span class="c1">//Description : Demo of pointer.</span>

<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

  <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="mi">8</span><span class="p">);</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>

  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">=</span><span class="n">i</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Content at %dth location is %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">q</span><span class="o">++</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>output:</p>
<div class="highlight-python"><div class="highlight"><pre>Content at 0th location is 0.
Content at 1th location is 1.
Content at 2th location is 2.
Content at 3th location is 3.
Content at 4th location is 4.
Content at 5th location is 5.
Content at 6th location is 6.
Content at 7th location is 7.
</pre></div>
</div>
</div>
<div class="section" id="address-and-indirection-operators">
<span id="index-8"></span><h2>6.4. Address and Indirection Operators<a class="headerlink" href="#address-and-indirection-operators" title="Permalink to this headline">¶</a></h2>
<p>As is the case with subscript operator and pointer arithmetic in the fourth
chapter that I have delayed these two as well for I wanted to put them here.
Whenever you declare a plain variable you have an address associated with it and
that variable is an lvalue. Just to repeat an lvalue is a value whose address can
be taken. To take the address of an lvalue you use the address operator which is
<code class="docutils literal"><span class="pre">&amp;</span></code>. Now a pointer points to address of any value as we know so we can use
address operator to get the address and use a pointer to store. There are several
usage of storing an address. Most notable of those is pass-by-address which we
will see in next chapter which will deal with functions. Let us say we take
address of a variable and assign that to a pointer. Then if we change the value
of the memory pointed to by the pointer then the variable whose address has been
taken will get updated with this new value. Consider for example:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">//Author: Shiv S. Dayal</span>
<span class="c1">//Description : Demo of pointer.</span>

<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span>  <span class="n">i</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span>

  <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;i=%d *p=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>output:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">i</span><span class="o">=</span><span class="mi">7</span> <span class="o">*</span><span class="n">p</span><span class="o">=</span><span class="mi">7</span>
</pre></div>
</div>
<p>So you see the power of pointers that if you have an address you can modify its
contents. This is exacly what <code class="docutils literal"><span class="pre">scanf()</span></code> does. The dereference operator or
indirection operator or aterisk (*) gives you value at address pointed to by
pointer <code class="docutils literal"><span class="pre">p</span></code>. However, if you want to change address of some varible like that
ofi by doing something like <code class="docutils literal"><span class="pre">&amp;i=&amp;someOthervar;</span></code> you cannot do that because
address is not an lvalue. However, you can pass address of a pointer variable to
some other function and use it using pointer to pointer notation which I will
show you in next chapter. As I have shown pointers are kind of equivalent to
array except the fact that they are on heap and sizeof operator will not work on
them. Consider this example:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">//Author: Shiv S. Dayal</span>
<span class="c1">//Description : Demo of pointer.</span>

<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span>  <span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">};</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">p</span>    <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">q</span>    <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;i=%d *p=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="n">i</span><span class="p">));</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Size of a=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="p">));</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Size of p=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Size of q=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">q</span><span class="p">));</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>output:</p>
<div class="highlight-python"><div class="highlight"><pre>i=0 *p=1
i=1 *p=2
i=2 *p=3
i=3 *p=4
Size of a=16
Size of p=4
Size of q=4
</pre></div>
</div>
<p>Here <code class="docutils literal"><span class="pre">p</span></code> acts as pointer to array. You can have a pointer to any kind of array.
You can point to any element of array because array elements are lvalues whose
addresses can be taken and to initialize a pointer alll you need is an address.</p>
<p><strong>Advice:</strong> Complex pointer arithmetic is best avoided. Be very thoughtful that
if you really really need it. Use loops to iterate arrays. Multiple levels of
indirection is also bad. Typically I have not seen more than pointers to
pointers. Now we will see array of pointers.</p>
</div>
<div class="section" id="arrays-of-pointers">
<span id="index-9"></span><h2>6.5. Arrays of Pointers<a class="headerlink" href="#arrays-of-pointers" title="Permalink to this headline">¶</a></h2>
<p>Pointers are just like ordinary variables so we can as well create array of
pointers. Consider following for example:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">//Author: Shiv S. Dayal</span>
<span class="c1">//Description : Demo of pointer.</span>

<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">strArray</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="s">&quot;Hello&quot;</span><span class="p">,</span> <span class="s">&quot;Universe!&quot;</span><span class="p">};</span>

  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">strArray</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>output:</p>
<div class="highlight-python"><div class="highlight"><pre>Hello
Universe!
</pre></div>
</div>
<p>Note how the length of two array elements are different as they are pointers. Let
us do a more complex example.</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">//Author: Shiv S. Dayal</span>
<span class="c1">//Description : Demo of pointer.</span>

<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">intArray</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

  <span class="n">intArray</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
  <span class="n">intArray</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>

  <span class="o">*</span><span class="n">intArray</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>     <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
  <span class="o">*</span><span class="p">(</span><span class="n">intArray</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="o">*</span><span class="p">(</span><span class="n">intArray</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>


  <span class="o">*</span><span class="n">intArray</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>     <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="o">*</span><span class="p">(</span><span class="n">intArray</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Memory location=%p Content=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">intArray</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">intArray</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">i</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Memory location=%p Content=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">intArray</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">intArray</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">i</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>output:</p>
<div class="highlight-python"><div class="highlight"><pre>Memory location=0x87d1008 Content=4
Memory location=0x87d100c Content=5
Memory location=0x87d1010 Content=6
Memory location=0x87d1018 Content=1
Memory location=0x87d101c Content=2
</pre></div>
</div>
<p>Note missing four bytes between 6 and 1. Memory locations may be different on
your system. But see how messy pointer syntax can go even with such simple code.
Array to pointers are useful for containing variables of dynamic size of same
type.</p>
<p>Pointers to pointers are same as array of pointers. The only difference is that
you can dynamically modify the number of elements.</p>
</div>
<div class="section" id="pointers-of-pointers">
<span id="index-10"></span><h2>6.6. Pointers of Pointers<a class="headerlink" href="#pointers-of-pointers" title="Permalink to this headline">¶</a></h2>
<p>Consider the following example:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">//Author: Shiv S. Dayal</span>
<span class="c1">//Description : Demo of pointer.</span>

<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span><span class="o">**</span> <span class="n">intPtr</span><span class="p">;</span>

  <span class="n">intPtr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">**</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">));</span>

  <span class="o">*</span><span class="n">intPtr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span><span class="p">);</span>
  <span class="o">*</span><span class="p">(</span><span class="n">intPtr</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">);</span>

  <span class="o">**</span><span class="n">intPtr</span>     <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">intPtr</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">intPtr</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>


  <span class="o">**</span><span class="p">(</span><span class="n">intPtr</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>      <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
  <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">intPtr</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">intPtr</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>  <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
  <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">intPtr</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span>  <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>

  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Memory location=%p content=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">intPtr</span><span class="o">+</span><span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">intPtr</span><span class="o">+</span><span class="n">i</span><span class="p">));</span>

  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Memory location=%p content=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">intPtr</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">intPtr</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">i</span><span class="p">));</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>output:</p>
<div class="highlight-python"><div class="highlight"><pre>Memory location=0x9947018 content=1
Memory location=0x994701c content=2
Memory location=0x9947020 content=7
Memory location=0x9947028 content=3
Memory location=0x994702c content=5
Memory location=0x9947030 content=9
Memory location=0x9947034 content=11
</pre></div>
</div>
<p>Again memory location may change on your system. As you can see how things can
get messy with pointers. Believe me you will hate this. Also, I do not see any
reason to use more than two levels of indirection. So you get the idea. If you
need dynamic no. of elements with dynamic content you are going to use pointers
to pointers.</p>
</div>
<div class="section" id="realloc-function">
<span id="index-11"></span><h2>6.7. realloc() Function<a class="headerlink" href="#realloc-function" title="Permalink to this headline">¶</a></h2>
<p>Once <code class="docutils literal"><span class="pre">malloc()</span></code> and <code class="docutils literal"><span class="pre">calloc()</span></code> allocate some memory you have that certain
amount of memory available to you. When you have an array you have some memory
but what if you want more later. <code class="docutils literal"><span class="pre">reallloc()</span></code> comes to rescue you. Here is a
sample program:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="c1">//Author: Shiv S. Dayal</span>
<span class="c1">//Description : Demo of pointer.</span>

<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">);</span>

  <span class="o">*</span><span class="n">p</span>     <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Original 1st element=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Original 2nd element=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>

  <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">realloc</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">);</span>

  <span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
  <span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;New 1st element=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;New 2nd element=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;New 3rd element=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">2</span><span class="p">));</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;New 4th element=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">3</span><span class="p">));</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>output:</p>
<div class="highlight-python"><div class="highlight"><pre>Original 1st element=5
Original 2nd element=7
New 1st element=5
New 2nd element=7
New 3rd element=9
New 4th element=11
</pre></div>
</div>
</div>
<div class="section" id="free-function">
<span id="index-12"></span><h2>6.8. free() Function<a class="headerlink" href="#free-function" title="Permalink to this headline">¶</a></h2>
<p>Whatever program we have written in this chapter related to dynamic memory
allocation using <code class="docutils literal"><span class="pre">malloc()</span></code> etc are utter piece of crap just because we are not
releasing memory properly. Any call to memory allocation functions have to be
matched with a corresponding <code class="docutils literal"><span class="pre">free()</span></code> call. The reason for this is that when
all pointers to a memory area are lost and that memory is not freed then
operating system cannot recycle that memory. In case of servers or long running
processes this may eat up all the physical RAM and virtual memory and eventually
freeze the system. To guard against such events you must macth all allocation
calls with deallocation calls so that operating system can reclaim the freed
memmory.</p>
<p>You must heed this warning given here with all of your focus. You got to handle
heap that is dynamically allocated memory yourself. You allocate and you free it.
If you miss you have a memory leak.</p>
</div>
<div class="section" id="constness">
<span id="index-13"></span><h2>6.9. Constness<a class="headerlink" href="#constness" title="Permalink to this headline">¶</a></h2>
<p>To make anything constant you need to associate <code class="docutils literal"><span class="pre">const</span></code> keyword with it. For
example, <code class="docutils literal"><span class="pre">const</span> <span class="pre">int</span> <span class="pre">i;</span> <span class="pre">const</span> <span class="pre">float</span> <span class="pre">f;</span></code>. However, with pointers in picture
scenarios change compared to two simple previous examples. When pointers are made
constant there are two elements. First is the pointer itself and second is the
value pointed to. Consider for example:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">i</span><span class="p">;</span>  <span class="c1">//constant pointer data is not</span>
<span class="kt">int</span><span class="o">*</span> <span class="k">const</span> <span class="n">i</span><span class="p">;</span>  <span class="c1">//constant data pointer is not</span>
<span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="k">const</span> <span class="n">i</span><span class="p">;</span> <span class="c1">//both are const</span>
</pre></div>
</div>
<p>The way to read it is you draw a vertical line where asterisk(*) is there and the
value associated with <code class="docutils literal"><span class="pre">const</span></code> is constant. Whenever you need use a constant
freely. Try to use constants more and more. Also, prefre them to following:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cp">#define MAX 10</span>
</pre></div>
</div>
<p>As told and shown to you it will replace <code class="docutils literal"><span class="pre">MAX</span></code> with 10 in the file everywhere
without any concern of type-safety. Also, it does not enter in the symbol table
so while debugging you will not see MAX anywhere. So instead you should use
something like:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">const</span> <span class="kt">int</span> <span class="n">MAX</span><span class="o">=</span><span class="mi">10</span><span class="p">;</span>
</pre></div>
</div>
<p>I will also like to say something about volatile variables. Beginners are usually
convinced that volatile variables cannot be declraed as const. Let me iterate the
definitions once again. A const variable cannot be modifed by the program itself.
A volatile variable can be modified by sources other than the program itself.
Hence, a <code class="docutils literal"><span class="pre">const</span> <span class="pre">volatile</span></code> variable cannot be modified by the program but other
sources can still modify it.</p>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../func/" class="btn btn-neutral float-right" title="7. Functions" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../cf/" class="btn btn-neutral" title="5. Control Flow" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2012-2015, Shiv S. Dayal.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>